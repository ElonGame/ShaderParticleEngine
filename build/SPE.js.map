{"version":3,"file":"SPE.js","sources":["../src/constants.js","../src/shaders/shaderChunks.js","../src/shaders/shaders.js","../src/helpers/ShaderAttribute.js","../src/helpers/TypedArrayHelper.js","../src/core/utils.js","../src/core/Emitter.js","../src/core/Group.js","../src/index.js"],"sourcesContent":["/**\n * @typedef {Number} distribution\n * @property {Number} SPE.distributions.BOX Values will be distributed within a box.\n * @property {Number} SPE.distributions.SPHERE Values will be distributed within a sphere.\n * @property {Number} SPE.distributions.DISC Values will be distributed within a 2D disc.\n */\n\n\n/**\n * A map of supported distribution types used\n * by SPE.Emitter instances.\n *\n * These distribution types can be applied to\n * an emitter globally, which will affect the\n * `position`, `velocity`, and `acceleration`\n * value calculations for an emitter, or they\n * can be applied on a per-property basis.\n *\n * @enum {Number}\n */\nexport const distributions = {\n    /**\n     * Values will be distributed within a box.\n     * @type {Number}\n     */\n    BOX: 1,\n\n    /**\n     * Values will be distributed on a sphere.\n     * @type {Number}\n     */\n    SPHERE: 2,\n\n    /**\n     * Values will be distributed on a 2d-disc shape.\n     * @type {Number}\n     */\n    DISC: 3\n};\n\n/**\n * Set this value to however many 'steps' you\n * want value-over-lifetime properties to have.\n *\n * It's adjustable to fix an interpolation problem:\n *\n * Assuming you specify an opacity value as [0, 1, 0]\n *      and the `valueOverLifetimeLength` is 4, then the\n *      opacity value array will be reinterpolated to\n *      be [0, 0.66, 0.66, 0].\n *   This isn't ideal, as particles would never reach\n *   full opacity.\n *\n * NOTE:\n *     This property affects the length of ALL\n *       value-over-lifetime properties for ALL\n *       emitters and ALL groups.\n *\n *     Only values >= 3 && <= 4 are allowed.\n *\n * @type {Number}\n */\nexport const valueOverLifetimeLength = '4';\n\n/**\n * A map of uniform types to their component size.\n * @enum {Number}\n */\nexport const typeSizeMap = {\n    /**\n     * Float\n     * @type {Number}\n     */\n    f: 1,\n\n    /**\n     * Vec2\n     * @type {Number}\n     */\n    v2: 2,\n\n    /**\n     * Vec3\n     * @type {Number}\n     */\n    v3: 3,\n\n    /**\n     * Vec4\n     * @type {Number}\n     */\n    v4: 4,\n\n    /**\n     * Color\n     * @type {Number}\n     */\n    c: 3,\n\n    /**\n     * Mat3\n     * @type {Number}\n     */\n    m3: 9,\n\n    /**\n     * Mat4\n     * @type {Number}\n     */\n    m4: 16\n};","const shaderChunks = {\n    // Register color-packing define statements.\n    defines: [\n        '#define PACKED_COLOR_SIZE 256.0',\n        '#define PACKED_COLOR_DIVISOR 255.0'\n    ].join( '\\n' ),\n\n    // All uniforms used by vertex / fragment shaders\n    uniforms: [\n        'uniform float deltaTime;',\n        'uniform float runTime;',\n        'uniform sampler2D texture;',\n        'uniform vec4 textureAnimation;',\n        'uniform float scale;',\n    ].join( '\\n' ),\n\n    // All attributes used by the vertex shader.\n    //\n    // Note that some attributes are squashed into other ones:\n    //\n    // * Drag is acceleration.w\n    attributes: [\n        'attribute vec4 acceleration;',\n        'attribute vec3 velocity;',\n        'attribute vec4 rotation;',\n        'attribute vec3 rotationCenter;',\n        'attribute vec4 params;',\n        'attribute vec4 size;',\n        'attribute vec4 angle;',\n        'attribute vec4 color;',\n        'attribute vec4 opacity;'\n    ].join( '\\n' ),\n\n    //\n    varyings: [\n        'varying vec4 vColor;',\n        '#ifdef SHOULD_ROTATE_TEXTURE',\n        '    varying float vAngle;',\n        '#endif',\n\n        '#ifdef SHOULD_CALCULATE_SPRITE',\n        '    varying vec4 vSpriteSheet;',\n        '#endif'\n    ].join( '\\n' ),\n\n\n    // Branch-avoiding comparison fns\n    // - http://theorangeduck.com/page/avoiding-shader-conditionals\n    branchAvoidanceFunctions: [\n        'float when_gt(float x, float y) {',\n        '    return max(sign(x - y), 0.0);',\n        '}',\n\n        'float when_lt(float x, float y) {',\n        '    return min( max(1.0 - sign(x - y), 0.0), 1.0 );',\n        '}',\n\n        'float when_eq( float x, float y ) {',\n        '    return 1.0 - abs( sign( x - y ) );',\n        '}',\n\n        'float when_ge(float x, float y) {',\n        '  return 1.0 - when_lt(x, y);',\n        '}',\n\n        'float when_le(float x, float y) {',\n        '  return 1.0 - when_gt(x, y);',\n        '}',\n\n        // Branch-avoiding logical operators\n        // (to be used with above comparison fns)\n        'float and(float a, float b) {',\n        '    return a * b;',\n        '}',\n\n        'float or(float a, float b) {',\n        '    return min(a + b, 1.0);',\n        '}',\n    ].join( '\\n' ),\n\n\n    // From:\n    // - http://stackoverflow.com/a/12553149\n    // - https://stackoverflow.com/questions/22895237/hexadecimal-to-rgb-values-in-webgl-shader\n    unpackColor: [\n        'vec3 unpackColor( in float hex ) {',\n        '   vec3 c = vec3( 0.0 );',\n\n        '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n        '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n        '   float b = mod( hex, PACKED_COLOR_SIZE );',\n\n        '   c.r = r / PACKED_COLOR_DIVISOR;',\n        '   c.g = g / PACKED_COLOR_DIVISOR;',\n        '   c.b = b / PACKED_COLOR_DIVISOR;',\n\n        '   return c;',\n        '}',\n    ].join( '\\n' ),\n\n    unpackRotationAxis: [\n        'vec3 unpackRotationAxis( in float hex ) {',\n        '   vec3 c = vec3( 0.0 );',\n\n        '   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n        '   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );',\n        '   float b = mod( hex, PACKED_COLOR_SIZE );',\n\n        '   c.r = r / PACKED_COLOR_DIVISOR;',\n        '   c.g = g / PACKED_COLOR_DIVISOR;',\n        '   c.b = b / PACKED_COLOR_DIVISOR;',\n\n        '   c *= vec3( 2.0 );',\n        '   c -= vec3( 1.0 );',\n\n        '   return c;',\n        '}',\n    ].join( '\\n' ),\n\n    floatOverLifetime: [\n        'float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {',\n        '    highp float value = 0.0;',\n        '    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );',\n        '    float fIndex = 0.0;',\n        '    float shouldApplyValue = 0.0;',\n\n        // This might look a little odd, but it's faster in the testing I've done than using branches.\n        // Uses basic maths to avoid branching.\n        //\n        // Take a look at the branch-avoidance functions defined above,\n        // and be sure to check out The Orange Duck site where I got this\n        // from (link above).\n\n        // Fix for static emitters (age is always zero).\n        '    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );',\n        '',\n        '    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {',\n        '       fIndex = float( i );',\n        '       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );',\n        '       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );',\n        '    }',\n        '',\n        '    return value;',\n        '}',\n    ].join( '\\n' ),\n\n    colorOverLifetime: [\n        'vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {',\n        '    vec3 value = vec3( 0.0 );',\n        '    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );',\n        '    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );',\n        '    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );',\n        '    return value;',\n        '}',\n    ].join( '\\n' ),\n\n    paramFetchingFunctions: [\n        'float getAlive() {',\n        '   return params.x;',\n        '}',\n\n        'float getAge() {',\n        '   return params.y;',\n        '}',\n\n        'float getMaxAge() {',\n        '   return params.z;',\n        '}',\n\n        'float getWiggle() {',\n        '   return params.w;',\n        '}',\n    ].join( '\\n' ),\n\n    forceFetchingFunctions: [\n        'vec4 getPosition( in float age ) {',\n        '   return modelViewMatrix * vec4( position, 1.0 );',\n        '}',\n\n        'vec3 getVelocity( in float age ) {',\n        '   return velocity * age;',\n        '}',\n\n        'vec3 getAcceleration( in float age ) {',\n        '   return acceleration.xyz * age;',\n        '}',\n    ].join( '\\n' ),\n\n\n    rotationFunctions: [\n        // Huge thanks to:\n        // - http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n        '#ifdef SHOULD_ROTATE_PARTICLES',\n        '   mat4 getRotationMatrix( in vec3 axis, in float angle) {',\n        '       axis = normalize(axis);',\n        '       float s = sin(angle);',\n        '       float c = cos(angle);',\n        '       float oc = 1.0 - c;',\n        '',\n        '       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,',\n        '                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,',\n        '                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,',\n        '                   0.0,                                0.0,                                0.0,                                1.0);',\n        '   }',\n        '',\n        '   vec3 getRotation( in vec3 pos, in float positionInTime ) {',\n        '      if( rotation.y == 0.0 ) {',\n        '           return pos;',\n        '      }',\n        '',\n        '      vec3 axis = unpackRotationAxis( rotation.x );',\n        '      vec3 center = rotationCenter;',\n        '      vec3 translated;',\n        '      mat4 rotationMatrix;',\n\n        '      float angle = 0.0;',\n        '      angle += when_eq( rotation.z, 0.0 ) * rotation.y;',\n        '      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );',\n        '      translated = rotationCenter - pos;',\n        '      rotationMatrix = getRotationMatrix( axis, angle );',\n        '      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );',\n        '   }',\n        '#endif'\n    ].join( '\\n' ),\n\n\n    // Fragment chunks\n    rotateTexture: [\n        '    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );',\n        '',\n        '    #ifdef SHOULD_ROTATE_TEXTURE',\n        '       float x = gl_PointCoord.x - 0.5;',\n        '       float y = 1.0 - gl_PointCoord.y - 0.5;',\n        '       float c = cos( -vAngle );',\n        '       float s = sin( -vAngle );',\n\n        '       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );',\n        '    #endif',\n        '',\n\n        // Spritesheets overwrite angle calculations.\n        '    #ifdef SHOULD_CALCULATE_SPRITE',\n        '        float framesX = vSpriteSheet.x;',\n        '        float framesY = vSpriteSheet.y;',\n        '        float columnNorm = vSpriteSheet.z;',\n        '        float rowNorm = vSpriteSheet.w;',\n\n        '        vUv.x = gl_PointCoord.x * framesX + columnNorm;',\n        '        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);',\n        '    #endif',\n\n        '',\n        '    vec4 rotatedTexture = texture2D( texture, vUv );',\n    ].join( '\\n' )\n};\n\nexport default shaderChunks;","import { ShaderChunk } from 'three';\nimport shaderChunks from './shaderChunks';\n\nconst shaders = {\n    vertex: [\n        shaderChunks.defines,\n        shaderChunks.uniforms,\n        shaderChunks.attributes,\n        shaderChunks.varyings,\n\n        ShaderChunk.common,\n        ShaderChunk.logdepthbuf_pars_vertex,\n\n        shaderChunks.branchAvoidanceFunctions,\n        shaderChunks.unpackColor,\n        shaderChunks.unpackRotationAxis,\n        shaderChunks.floatOverLifetime,\n        shaderChunks.colorOverLifetime,\n        shaderChunks.paramFetchingFunctions,\n        shaderChunks.forceFetchingFunctions,\n        shaderChunks.rotationFunctions,\n\n\n        'void main() {',\n\n\n        //\n        // Setup...\n        //\n        '    highp float age = getAge();',\n        '    highp float alive = getAlive();',\n        '    highp float maxAge = getMaxAge();',\n        '    highp float positionInTime = (age / maxAge);',\n        '    highp float isAlive = when_gt( alive, 0.0 );',\n\n        '    #ifdef SHOULD_WIGGLE_PARTICLES',\n        '        float wiggleAmount = positionInTime * getWiggle();',\n        '        float wiggleSin = isAlive * sin( wiggleAmount );',\n        '        float wiggleCos = isAlive * cos( wiggleAmount );',\n        '    #endif',\n\n        //\n        // Forces\n        //\n\n        // Get forces & position\n        '    vec3 vel = getVelocity( age );',\n        '    vec3 accel = getAcceleration( age );',\n        '    vec3 force = vec3( 0.0 );',\n        '    vec3 pos = vec3( position );',\n\n        // Calculate the required drag to apply to the forces.\n        '    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;',\n\n        // Integrate forces...\n        '    force += vel;',\n        '    force *= drag;',\n        '    force += accel * age;',\n        '    pos += force;',\n\n\n        // Wiggly wiggly wiggle!\n        '    #ifdef SHOULD_WIGGLE_PARTICLES',\n        '        pos.x += wiggleSin;',\n        '        pos.y += wiggleCos;',\n        '        pos.z += wiggleSin;',\n        '    #endif',\n\n\n        // Rotate the emitter around it's central point\n        '    #ifdef SHOULD_ROTATE_PARTICLES',\n        '        pos = getRotation( pos, positionInTime );',\n        '    #endif',\n\n        // Convert pos to a world-space value\n        '    vec4 mvPos = modelViewMatrix * vec4( pos, 1.0 );',\n\n        // Determine point size.\n        '    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;',\n\n        // Determine perspective\n        '    #ifdef HAS_PERSPECTIVE',\n        '        float perspective = scale / length( mvPos.xyz );',\n        '    #else',\n        '        float perspective = 1.0;',\n        '    #endif',\n\n        // Apply perpective to pointSize value\n        '    float pointSizePerspective = pointSize * perspective;',\n\n\n        //\n        // Appearance\n        //\n\n        // Determine color and opacity for this particle\n        '    #ifdef COLORIZE',\n        '       vec3 c = isAlive * getColorOverLifetime(',\n        '           positionInTime,',\n        '           unpackColor( color.x ),',\n        '           unpackColor( color.y ),',\n        '           unpackColor( color.z ),',\n        '           unpackColor( color.w )',\n        '       );',\n        '    #else',\n        '       vec3 c = vec3(1.0);',\n        '    #endif',\n\n        '    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );',\n\n        // Assign color to vColor varying.\n        '    vColor = vec4( c, o );',\n\n        // Determine angle\n        '    #ifdef SHOULD_ROTATE_TEXTURE',\n        '        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );',\n        '    #endif',\n\n        // If this particle is using a sprite-sheet as a texture, we'll have to figure out\n        // what frame of the texture the particle is using at it's current position in time.\n        '    #ifdef SHOULD_CALCULATE_SPRITE',\n        '        float framesX = textureAnimation.x;',\n        '        float framesY = textureAnimation.y;',\n        '        float loopCount = textureAnimation.w;',\n        '        float totalFrames = textureAnimation.z;',\n        '        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );',\n\n        '        float column = floor(mod( frameNumber, framesX ));',\n        '        float row = floor( (frameNumber - column) / framesX );',\n\n        '        float columnNorm = column / framesX;',\n        '        float rowNorm = row / framesY;',\n\n        '        vSpriteSheet.x = 1.0 / framesX;',\n        '        vSpriteSheet.y = 1.0 / framesY;',\n        '        vSpriteSheet.z = columnNorm;',\n        '        vSpriteSheet.w = rowNorm;',\n        '    #endif',\n\n        //\n        // Write values\n        //\n\n        // Set PointSize according to size at current point in time.\n        '    gl_PointSize = pointSizePerspective;',\n        '    gl_Position = projectionMatrix * mvPos;',\n\n        ShaderChunk.logdepthbuf_vertex,\n\n        '}'\n    ].join( '\\n' ),\n\n    fragment: [\n        shaderChunks.uniforms,\n\n        ShaderChunk.common,\n        ShaderChunk.fog_pars_fragment,\n        ShaderChunk.logdepthbuf_pars_fragment,\n\n        shaderChunks.varyings,\n\n        shaderChunks.branchAvoidanceFunctions,\n\n        'void main() {',\n        '    vec3 outgoingLight = vColor.xyz;',\n        '    ',\n        '    #ifdef ALPHATEST',\n        '       if ( vColor.w < float(ALPHATEST) ) discard;',\n        '    #endif',\n\n        shaderChunks.rotateTexture,\n\n        ShaderChunk.logdepthbuf_fragment,\n\n        '    outgoingLight = vColor.xyz * rotatedTexture.xyz;',\n\n        ShaderChunk.fog_fragment,\n\n        '    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );',\n        '}'\n    ].join( '\\n' )\n};\n\nexport default shaders;","import { BufferAttribute } from 'three';\nimport { typeSizeMap } from '../constants';\n\n\n/**\n * A helper to handle creating and updating a THREE.BufferAttribute instance.\n *\n * @author  Luke Moody\n * @constructor\n * @param {String} type          The buffer attribute type. See SPE.typeSizeMap for valid values.\n * @param {Boolean=} dynamicBuffer Whether this buffer attribute should be marked as dynamic or not.\n * @param {Function=} arrayType     A reference to a TypedArray constructor. Defaults to Float32Array if none provided.\n */\nexport default class ShaderAttribute {\n    constructor( type, dynamicBuffer, arrayType = Float32Array ) {\n        const typeMap = typeSizeMap;\n\n        this.type = typeof type === 'string' && typeMap.hasOwnProperty( type ) ? type : 'f';\n        this.componentSize = typeMap[ this.type ];\n        this.arrayType = arrayType;\n        this.typedArray = null;\n        this.bufferAttribute = null;\n        this.dynamicBuffer = !!dynamicBuffer;\n\n        this.updateMin = 0;\n        this.updateMax = 0;\n    }\n\n    /**\n     * Calculate the minimum and maximum update range for this buffer attribute using\n     * component size independant min and max values.\n     *\n     * @param {Number} min The start of the range to mark as needing an update.\n     * @param {Number} max The end of the range to mark as needing an update.\n     */\n    setUpdateRange( min, max ) {\n        this.updateMin = Math.min( min * this.componentSize, this.updateMin * this.componentSize );\n        this.updateMax = Math.max( max * this.componentSize, this.updateMax * this.componentSize );\n    }\n\n    /**\n     * Calculate the number of indices that this attribute should mark as needing\n     * updating. Also marks the attribute as needing an update.\n     */\n    flagUpdate() {\n        const attr = this.bufferAttribute,\n            range = attr.updateRange;\n\n        range.offset = this.updateMin;\n        range.count = Math.min( ( this.updateMax - this.updateMin ) + this.componentSize, this.typedArray.array.length );\n        // console.log( range.offset, range.count, this.typedArray.array.length );\n        // console.log( 'flagUpdate:', range.offset, range.count );\n        attr.needsUpdate = true;\n    }\n\n    /**\n     * Reset the index update counts for this attribute\n     */\n    resetUpdateRange() {\n        this.updateMin = 0;\n        this.updateMax = 0;\n    }\n\n    resetDynamic() {\n        this.bufferAttribute.dynamic = this.dynamicBuffer;\n    }\n\n    /**\n     * Perform a splice operation on this attribute's buffer.\n     * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.\n     * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.\n     */\n    splice( start, end ) {\n        this.typedArray.splice( start, end );\n\n        // Reset the reference to the attribute's typed array\n        // since it has probably changed.\n        this.forceUpdateAll();\n    }\n\n    forceUpdateAll() {\n        this.bufferAttribute.array = this.typedArray.array;\n        this.bufferAttribute.updateRange.offset = 0;\n        this.bufferAttribute.updateRange.count = -1;\n        this.bufferAttribute.dynamic = false;\n        this.bufferAttribute.needsUpdate = true;\n    }\n\n    /**\n     * Make sure this attribute has a typed array associated with it.\n     *\n     * If it does, then it will ensure the typed array is of the correct size.\n     *\n     * If not, a new SPE.TypedArrayHelper instance will be created.\n     *\n     * @param  {Number} size The size of the typed array to create or update to.\n     */\n    _ensureTypedArray( size ) {\n        // Condition that's most likely to be true at the top: no change.\n        if ( this.typedArray !== null && this.typedArray.size === size * this.componentSize ) {\n            return;\n        }\n\n        // Resize the array if we need to, telling the TypedArrayHelper to\n        // ignore it's component size when evaluating size.\n        else if ( this.typedArray !== null && this.typedArray.size !== size ) {\n            this.typedArray.setSize( size );\n        }\n\n        // This condition should only occur once in an attribute's lifecycle.\n        else if ( this.typedArray === null ) {\n            this.typedArray = new SPE.TypedArrayHelper( this.arrayType, size, this.componentSize );\n        }\n    }\n\n    /**\n     * Creates a THREE.BufferAttribute instance if one doesn't exist already.\n     *\n     * Ensures a typed array is present by calling _ensureTypedArray() first.\n     *\n     * If a buffer attribute exists already, then it will be marked as needing an update.\n     *\n     * @param  {Number} size The size of the typed array to create if one doesn't exist, or resize existing array to.\n     */\n    _createBufferAttribute( size ) {\n        // Make sure the typedArray is present and correct.\n        this._ensureTypedArray( size );\n\n        // Don't create it if it already exists, but do\n        // flag that it needs updating on the next render\n        // cycle.\n        if ( this.bufferAttribute !== null ) {\n            this.bufferAttribute.array = this.typedArray.array;\n            this.bufferAttribute.needsUpdate = true;\n            return;\n        }\n\n        this.bufferAttribute = new BufferAttribute( this.typedArray.array, this.componentSize );\n        this.bufferAttribute.dynamic = this.dynamicBuffer;\n    }\n\n    /**\n     * Returns the length of the typed array associated with this attribute.\n     * @return {Number} The length of the typed array. Will be 0 if no typed array has been created yet.\n     */\n    getLength() {\n        if ( this.typedArray === null ) {\n            return 0;\n        }\n\n        return this.typedArray.array.length;\n    }\n}","/**\n * A helper class for TypedArrays.\n *\n * Allows for easy resizing, assignment of various component-based\n * types (Vector2s, Vector3s, Vector4s, Mat3s, Mat4s),\n * as well as Colors (where components are `r`, `g`, `b`),\n * Numbers, and setting from other TypedArrays.\n *\n * @author Luke Moody\n * @constructor\n * @param {Function} TypedArrayConstructor The constructor to use (Float32Array, Uint8Array, etc.)\n * @param {Number} size                 The size of the array to create\n * @param {Number} componentSize        The number of components per-value (ie. 3 for a vec3, 9 for a Mat3, etc.)\n * @param {Number} indexOffset          The index in the array from which to start assigning values. Default `0` if none provided\n */\nexport default class TypedArrayHelper {\n    constructor(\n        TypedArrayConstructor = Float32Array,\n        size = 1,\n        componentSize = 1,\n        indexOffset = 0\n    ) {\n        this.componentSize = componentSize;\n        this.size = size;\n        this.TypedArrayConstructor = TypedArrayConstructor;\n        this.array = new TypedArrayConstructor( size * this.componentSize );\n        this.indexOffset = indexOffset;\n    }\n\n    /**\n     * Sets the size of the internal array.\n     *\n     * Delegates to `this.shrink` or `this.grow` depending on size\n     * argument's relation to the current size of the internal array.\n     *\n     * Note that if the array is to be shrunk, data will be lost.\n     *\n     * @param {Number} size The new size of the array.\n     */\n    setSize( size, noComponentMultiply ) {\n        const currentArraySize = this.array.length;\n\n        if ( !noComponentMultiply ) {\n            size = size * this.componentSize;\n        }\n\n        if ( size < currentArraySize ) {\n            return this.shrink( size );\n        }\n        else if ( size > currentArraySize ) {\n            return this.grow( size );\n        }\n        else {\n            console.info( 'TypedArray is already of size:', size + '.', 'Will not resize.' );\n        }\n    }\n\n    /**\n     * Shrinks the internal array.\n     *\n     * @param  {Number} size The new size of the typed array. Must be smaller than `this.array.length`.\n     * @return {SPE.TypedArrayHelper}      Instance of this class.\n     */\n    shrink( size ) {\n        this.array = this.array.subarray( 0, size );\n        this.size = size;\n        return this;\n    }\n\n    /**\n     * Grows the internal array.\n     * @param  {Number} size The new size of the typed array. Must be larger than `this.array.length`.\n     * @return {SPE.TypedArrayHelper}      Instance of this class.\n     */\n    grow( size ) {\n        const existingArray = this.array,\n            newArray = new this.TypedArrayConstructor( size );\n\n        newArray.set( existingArray );\n        this.array = newArray;\n        this.size = size;\n\n        return this;\n    }\n\n\n    /**\n     * Perform a splice operation on this array's buffer.\n     * @param  {Number} start The start index of the splice. Will be multiplied by the number of components for this attribute.\n     * @param  {Number} end The end index of the splice. Will be multiplied by the number of components for this attribute.\n     * @returns {Object} The SPE.TypedArrayHelper instance.\n     */\n    splice( start, end ) {\n        start *= this.componentSize;\n        end *= this.componentSize;\n\n        const data = [],\n            array = this.array,\n            size = array.length;\n\n        for ( let i = 0; i < size; ++i ) {\n            if ( i < start || i >= end ) {\n                data.push( array[ i ] );\n            }\n            // array[ i ] = 0;\n        }\n\n        this.setFromArray( 0, data );\n\n        return this;\n    }\n\n\n    /**\n     * Copies from the given TypedArray into this one, using the index argument\n     * as the start position. Alias for `TypedArray.set`. Will automatically resize\n     * if the given source array is of a larger size than the internal array.\n     *\n     * @param {Number} index      The start position from which to copy into this array.\n     * @param {TypedArray} array The array from which to copy; the source array.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setFromArray( index, array ) {\n        const sourceArraySize = array.length,\n            newSize = index + sourceArraySize;\n\n        if ( newSize > this.array.length ) {\n            this.grow( newSize );\n        }\n        else if ( newSize < this.array.length ) {\n            this.shrink( newSize );\n        }\n\n        this.array.set( array, this.indexOffset + index );\n\n        return this;\n    }\n\n    /**\n     * Set a Vector2 value at `index`.\n     *\n     * @param {Number} index The index at which to set the vec2 values from.\n     * @param {Vector2} vec2  Any object that has `x` and `y` properties.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setVec2( index, vec2 ) {\n        return this.setVec2Components( index, vec2.x, vec2.y );\n    }\n\n    /**\n     * Set a Vector2 value using raw components.\n     *\n     * @param {Number} index The index at which to set the vec2 values from.\n     * @param {Number} x     The Vec2's `x` component.\n     * @param {Number} y     The Vec2's `y` component.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setVec2Components( index, x, y ) {\n        const array = this.array,\n            i = this.indexOffset + ( index * this.componentSize );\n\n        array[ i ] = x;\n        array[ i + 1 ] = y;\n        return this;\n    }\n\n    /**\n     * Set a Vector3 value at `index`.\n     *\n     * @param {Number} index The index at which to set the vec3 values from.\n     * @param {Vector3} vec2  Any object that has `x`, `y`, and `z` properties.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setVec3( index, vec3 ) {\n\n        return this.setVec3Components( index, vec3.x, vec3.y, vec3.z );\n    }\n\n    /**\n     * Set a Vector3 value using raw components.\n     *\n     * @param {Number} index The index at which to set the vec3 values from.\n     * @param {Number} x     The Vec3's `x` component.\n     * @param {Number} y     The Vec3's `y` component.\n     * @param {Number} z     The Vec3's `z` component.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setVec3Components( index, x, y, z ) {\n        var array = this.array,\n            i = this.indexOffset + ( index * this.componentSize );\n\n        array[ i ] = x;\n        array[ i + 1 ] = y;\n        array[ i + 2 ] = z;\n        return this;\n    }\n\n    /**\n     * Set a Vector4 value at `index`.\n     *\n     * @param {Number} index The index at which to set the vec4 values from.\n     * @param {Vector4} vec2  Any object that has `x`, `y`, `z`, and `w` properties.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setVec4( index, vec4 ) {\n        return this.setVec4Components( index, vec4.x, vec4.y, vec4.z, vec4.w );\n    }\n\n    /**\n     * Set a Vector4 value using raw components.\n     *\n     * @param {Number} index The index at which to set the vec4 values from.\n     * @param {Number} x     The Vec4's `x` component.\n     * @param {Number} y     The Vec4's `y` component.\n     * @param {Number} z     The Vec4's `z` component.\n     * @param {Number} w     The Vec4's `w` component.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setVec4Components( index, x, y, z, w ) {\n        var array = this.array,\n            i = this.indexOffset + ( index * this.componentSize );\n\n        array[ i ] = x;\n        array[ i + 1 ] = y;\n        array[ i + 2 ] = z;\n        array[ i + 3 ] = w;\n        return this;\n    }\n\n    /**\n     * Set a Matrix3 value at `index`.\n     *\n     * @param {Number} index The index at which to set the matrix values from.\n     * @param {Matrix3} mat3 The 3x3 matrix to set from. Must have a TypedArray property named `elements` to copy from.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setMat3( index, mat3 ) {\n        return this.setFromArray( this.indexOffset + ( index * this.componentSize ), mat3.elements );\n    }\n\n    /**\n     * Set a Matrix4 value at `index`.\n     *\n     * @param {Number} index The index at which to set the matrix values from.\n     * @param {Matrix4} mat3 The 4x4 matrix to set from. Must have a TypedArray property named `elements` to copy from.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setMat4( index, mat4 ) {\n        return this.setFromArray( this.indexOffset + ( index * this.componentSize ), mat4.elements );\n    }\n\n    /**\n     * Set a Color value at `index`.\n     *\n     * @param {Number} index The index at which to set the vec3 values from.\n     * @param {Color} color  Any object that has `r`, `g`, and `b` properties.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setColor( index, color ) {\n        return this.setVec3Components( index, color.r, color.g, color.b );\n    }\n\n    /**\n     * Set a Number value at `index`.\n     *\n     * @param {Number} index The index at which to set the vec3 values from.\n     * @param {Number} numericValue  The number to assign to this index in the array.\n     * @return {SPE.TypedArrayHelper} Instance of this class.\n     */\n    setNumber( index, numericValue ) {\n        this.array[ this.indexOffset + ( index * this.componentSize ) ] = numericValue;\n        return this;\n    }\n\n    /**\n     * Returns the value of the array at the given index, taking into account\n     * the `indexOffset` property of this class.\n     *\n     * Note that this function ignores the component size and will just return a\n     * single value.\n     *\n     * @param  {Number} index The index in the array to fetch.\n     * @return {Number}       The value at the given index.\n     */\n    getValueAtIndex( index ) {\n        return this.array[ this.indexOffset + index ];\n    }\n\n    /**\n     * Returns the component value of the array at the given index, taking into account\n     * the `indexOffset` property of this class.\n     *\n     * If the componentSize is set to 3, then it will return a new TypedArray\n     * of length 3.\n     *\n     * @param  {Number} index The index in the array to fetch.\n     * @return {TypedArray}       The component value at the given index.\n     */\n    getComponentValueAtIndex( index ) {\n        return this.array.subarray( this.indexOffset + ( index * this.componentSize ) );\n    }\n\n}","import { Vector2 as THREEVector2 } from 'three';\nimport { Vector3 as THREEVector3 } from 'three';\nimport { Vector4 as THREEVector4 } from 'three';\nimport { Color as THREEColor } from 'three';\n\n/**\n * A map of types used by `SPE.utils.ensureTypedArg` and\n * `SPE.utils.ensureArrayTypedArg` to compare types against.\n *\n * @enum {String}\n */\nexport const types = {\n    /**\n     * Boolean type.\n     * @type {String}\n     */\n    BOOLEAN: 'boolean',\n\n    /**\n     * String type.\n     * @type {String}\n     */\n    STRING: 'string',\n\n    /**\n     * Number type.\n     * @type {String}\n     */\n    NUMBER: 'number',\n\n    /**\n     * Object type.\n     * @type {String}\n     */\n    OBJECT: 'object'\n};\n\n/**\n * Given a value, a type, and a default value to fallback to,\n * ensure the given argument adheres to the type requesting,\n * returning the default value if type check is false.\n *\n * @param  {(boolean|string|number|object)} arg          The value to perform a type-check on.\n * @param  {String} type         The type the `arg` argument should adhere to.\n * @param  {(boolean|string|number|object)} defaultValue A default value to fallback on if the type check fails.\n * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.\n */\nexport function ensureTypedArg( arg, type, defaultValue ) {\n    if ( typeof arg === type ) {\n        return arg;\n    }\n    else {\n        return defaultValue;\n    }\n};\n\n/**\n * Given an array of values, a type, and a default value,\n * ensure the given array's contents ALL adhere to the provided type,\n * returning the default value if type check fails.\n *\n * If the given value to check isn't an Array, delegates to SPE.utils.ensureTypedArg.\n *\n * @param  {Array|boolean|string|number|object} arg          The array of values to check type of.\n * @param  {String} type         The type that should be adhered to.\n * @param  {(boolean|string|number|object)} defaultValue A default fallback value.\n * @return {(boolean|string|number|object)}              The given value if type check passes, or the default value if it fails.\n */\nexport function ensureArrayTypedArg( arg, type, defaultValue ) {\n    // If the argument being checked is an array, loop through\n    // it and ensure all the values are of the correct type,\n    // falling back to the defaultValue if any aren't.\n    if ( Array.isArray( arg ) ) {\n        for ( let i = arg.length - 1; i >= 0; --i ) {\n            if ( typeof arg[ i ] !== type ) {\n                return defaultValue;\n            }\n        }\n\n        return arg;\n    }\n\n    // If the arg isn't an array then just fallback to\n    // checking the type.\n    return ensureTypedArg( arg, type, defaultValue );\n};\n\n/**\n * Ensures the given value is an instance of a constructor function.\n *\n * @param  {Object} arg          The value to check instance of.\n * @param  {Function} instance     The constructor of the instance to check against.\n * @param  {Object} defaultValue A default fallback value if instance check fails\n * @return {Object}              The given value if type check passes, or the default value if it fails.\n */\nexport function ensureInstanceOf( arg, instance, defaultValue ) {\n    if ( instance !== undefined && arg instanceof instance ) {\n        return arg;\n    }\n    else {\n        return defaultValue;\n    }\n};\n\n/**\n * Given an array of values, ensure the instances of all items in the array\n * matches the given instance constructor falling back to a default value if\n * the check fails.\n *\n * If given value isn't an Array, delegates to `SPE.utils.ensureInstanceOf`.\n *\n * @param  {Array|Object} arg          The value to perform the instanceof check on.\n * @param  {Function} instance     The constructor of the instance to check against.\n * @param  {Object} defaultValue A default fallback value if instance check fails\n * @return {Object}              The given value if type check passes, or the default value if it fails.\n */\nexport function ensureArrayInstanceOf( arg, instance, defaultValue ) {\n    // If the argument being checked is an array, loop through\n    // it and ensure all the values are of the correct type,\n    // falling back to the defaultValue if any aren't.\n    if ( Array.isArray( arg ) ) {\n        for ( let i = arg.length - 1; i >= 0; --i ) {\n            if ( instance !== undefined && arg[ i ] instanceof instance === false ) {\n                return defaultValue;\n            }\n        }\n\n        return arg;\n    }\n\n    // If the arg isn't an array then just fallback to\n    // checking the type.\n    return ensureInstanceOf( arg, instance, defaultValue );\n};\n\n/**\n * Ensures that any \"value-over-lifetime\" properties of an emitter are\n * of the correct length (as dictated by `SPE.valueOverLifetimeLength`).\n *\n * Delegates to `SPE.utils.interpolateArray` for array resizing.\n *\n * If properties aren't arrays, then property values are put into one.\n *\n * @param  {Object} property  The property of an SPE.Emitter instance to check compliance of.\n * @param  {Number} minLength The minimum length of the array to create.\n * @param  {Number} maxLength The maximum length of the array to create.\n */\nexport function ensureValueOverLifetimeCompliance( property, minLength, maxLength ) {\n    minLength = minLength || 3;\n    maxLength = maxLength || 3;\n\n    // First, ensure both properties are arrays.\n    if ( Array.isArray( property._value ) === false ) {\n        property._value = [ property._value ];\n    }\n\n    if ( Array.isArray( property._spread ) === false ) {\n        property._spread = [ property._spread ];\n    }\n\n    var valueLength = clamp( property._value.length, minLength, maxLength ),\n        spreadLength = clamp( property._spread.length, minLength, maxLength ),\n        desiredLength = Math.max( valueLength, spreadLength );\n\n    if ( property._value.length !== desiredLength ) {\n        property._value = interpolateArray( property._value, desiredLength );\n    }\n\n    if ( property._spread.length !== desiredLength ) {\n        property._spread = interpolateArray( property._spread, desiredLength );\n    }\n};\n\n/**\n * Performs linear interpolation (lerp) on an array.\n *\n * For example, lerping [1, 10], with a `newLength` of 10 will produce [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].\n *\n * Delegates to `SPE.utils.lerpTypeAgnostic` to perform the actual\n * interpolation.\n *\n * @param  {Array} srcArray  The array to lerp.\n * @param  {Number} newLength The length the array should be interpolated to.\n * @return {Array}           The interpolated array.\n */\nexport function interpolateArray( srcArray, newLength ) {\n    const sourceLength = srcArray.length,\n        newArray = [ typeof srcArray[ 0 ].clone === 'function' ? srcArray[ 0 ].clone() : srcArray[ 0 ] ],\n        factor = ( sourceLength - 1 ) / ( newLength - 1 );\n\n\n    for ( var i = 1; i < newLength - 1; ++i ) {\n        var f = i * factor,\n            before = Math.floor( f ),\n            after = Math.ceil( f ),\n            delta = f - before;\n\n        newArray[ i ] = lerpTypeAgnostic( srcArray[ before ], srcArray[ after ], delta );\n    }\n\n    newArray.push(\n        typeof srcArray[ sourceLength - 1 ].clone === 'function' ?\n        srcArray[ sourceLength - 1 ].clone() :\n        srcArray[ sourceLength - 1 ]\n    );\n\n    return newArray;\n};\n\n/**\n * Clamp a number to between the given min and max values.\n * @param  {Number} value The number to clamp.\n * @param  {Number} min   The minimum value.\n * @param  {Number} max   The maximum value.\n * @return {Number}       The clamped number.\n */\nexport function clamp( value, min, max ) {\n    return Math.max( min, Math.min( value, max ) );\n};\n\n/**\n * If the given value is less than the epsilon value, then return\n * a randomised epsilon value if specified, or just the epsilon value if not.\n * Works for negative numbers as well as positive.\n *\n * @param  {Number} value     The value to perform the operation on.\n * @param  {Boolean} randomise Whether the value should be randomised.\n * @return {Number}           The result of the operation.\n */\nexport function zeroToEpsilon( value, randomise ) {\n    const epsilon = 0.00001;\n    let result = value;\n\n    result = randomise ? Math.random() * epsilon * 10 : epsilon;\n\n    if ( value < 0 && value > -epsilon ) {\n        result = -result;\n    }\n\n    // if ( value === 0 ) {\n    //     result = randomise ? Math.random() * epsilon * 10 : epsilon;\n    // }\n    // else if ( value > 0 && value < epsilon ) {\n    //     result = randomise ? Math.random() * epsilon * 10 : epsilon;\n    // }\n    // else if ( value < 0 && value > -epsilon ) {\n    //     result = -( randomise ? Math.random() * epsilon * 10 : epsilon );\n    // }\n\n    return result;\n};\n\n/**\n * Linearly interpolates two values of various types. The given values\n * must be of the same type for the interpolation to work.\n * @param  {(number|Object)} start The start value of the lerp.\n * @param  {(number|object)} end   The end value of the lerp.\n * @param  {Number} delta The delta posiiton of the lerp operation. Ideally between 0 and 1 (inclusive).\n * @return {(number|object|undefined)}       The result of the operation. Result will be undefined if\n *                                               the start and end arguments aren't a supported type, or\n *                                               if their types do not match.\n */\nexport function lerpTypeAgnostic( start, end, delta ) {\n    let out;\n\n    if ( typeof start === types.NUMBER && typeof end === types.NUMBER ) {\n        return start + ( ( end - start ) * delta );\n    }\n    else if ( start instanceof THREEVector2 && end instanceof THREEVector2 ) {\n        out = start.clone();\n        out.x = lerp( start.x, end.x, delta );\n        out.y = lerp( start.y, end.y, delta );\n        return out;\n    }\n    else if ( start instanceof THREEVector3 && end instanceof THREEVector3 ) {\n        out = start.clone();\n        out.x = lerp( start.x, end.x, delta );\n        out.y = lerp( start.y, end.y, delta );\n        out.z = lerp( start.z, end.z, delta );\n        return out;\n    }\n    else if ( start instanceof THREEVector4 && end instanceof THREEVector4 ) {\n        out = start.clone();\n        out.x = lerp( start.x, end.x, delta );\n        out.y = lerp( start.y, end.y, delta );\n        out.z = lerp( start.z, end.z, delta );\n        out.w = lerp( start.w, end.w, delta );\n        return out;\n    }\n    else if ( start instanceof THREEColor && end instanceof THREEColor ) {\n        out = start.clone();\n        out.r = lerp( start.r, end.r, delta );\n        out.g = lerp( start.g, end.g, delta );\n        out.b = lerp( start.b, end.b, delta );\n        return out;\n    }\n    else {\n        console.warn( 'Invalid argument types, or argument types do not match:', start, end );\n    }\n};\n\n/**\n * Perform a linear interpolation operation on two numbers.\n * @param  {Number} start The start value.\n * @param  {Number} end   The end value.\n * @param  {Number} delta The position to interpolate to.\n * @return {Number}       The result of the lerp operation.\n */\nexport function lerp( start, end, delta ) {\n    return start + ( ( end - start ) * delta );\n};\n\n/**\n * Rounds a number to a nearest multiple.\n *\n * @param  {Number} n        The number to round.\n * @param  {Number} multiple The multiple to round to.\n * @return {Number}          The result of the round operation.\n */\nexport function roundToNearestMultiple( n, multiple ) {\n    let remainder = 0;\n\n    if ( multiple === 0 ) {\n        return n;\n    }\n\n    remainder = Math.abs( n ) % multiple;\n\n    if ( remainder === 0 ) {\n        return n;\n    }\n\n    if ( n < 0 ) {\n        return -( Math.abs( n ) - remainder );\n    }\n\n    return n + multiple - remainder;\n};\n\n/**\n * Check if all items in an array are equal. Uses strict equality.\n *\n * @param  {Array} array The array of values to check equality of.\n * @return {Boolean}       Whether the array's values are all equal or not.\n */\nexport function arrayValuesAreEqual( array ) {\n    for ( let i = 0; i < array.length - 1; ++i ) {\n        if ( array[ i ] !== array[ i + 1 ] ) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n// colorsAreEqual() {\n//     var colors = Array.prototype.slice.call( arguments ),\n//         numColors = colors.length;\n\n//     for ( var i = 0, color1, color2; i < numColors - 1; ++i ) {\n//         color1 = colors[ i ];\n//         color2 = colors[ i + 1 ];\n\n//         if (\n//             color1.r !== color2.r ||\n//             color1.g !== color2.g ||\n//             color1.b !== color2.b\n//         ) {\n//             return false\n//         }\n//     }\n\n//     return true;\n// };\n\n\n/**\n * Given a start value and a spread value, create and return a random\n * number.\n * @param  {Number} base   The start value.\n * @param  {Number} spread The size of the random variance to apply.\n * @return {Number}        A randomised number.\n */\nexport function randomFloat( base, spread ) {\n    return base + spread * ( Math.random() - 0.5 );\n};\n\n/**\n * Given an SPE.ShaderAttribute instance, and various other settings,\n * assign values to the attribute's array in a `vec3` format.\n *\n * @param  {Object} attribute   The instance of SPE.ShaderAttribute to save the result to.\n * @param  {Number} index       The offset in the attribute's TypedArray to save the result from.\n * @param  {Object} base        THREE.Vector3 instance describing the start value.\n * @param  {Object} spread      THREE.Vector3 instance describing the random variance to apply to the start value.\n * @param  {Object} spreadClamp THREE.Vector3 instance describing the multiples to clamp the randomness to.\n */\nexport function randomVector3( attribute, index, base, spread, spreadClamp ) {\n    let x = base.x + ( Math.random() * spread.x - ( spread.x * 0.5 ) ),\n        y = base.y + ( Math.random() * spread.y - ( spread.y * 0.5 ) ),\n        z = base.z + ( Math.random() * spread.z - ( spread.z * 0.5 ) );\n\n    // var x = randomFloat( base.x, spread.x ),\n    // y = randomFloat( base.y, spread.y ),\n    // z = randomFloat( base.z, spread.z );\n\n    if ( spreadClamp ) {\n        x = -spreadClamp.x * 0.5 + roundToNearestMultiple( x, spreadClamp.x );\n        y = -spreadClamp.y * 0.5 + roundToNearestMultiple( y, spreadClamp.y );\n        z = -spreadClamp.z * 0.5 + roundToNearestMultiple( z, spreadClamp.z );\n    }\n\n    attribute.typedArray.setVec3Components( index, x, y, z );\n};\n\n/**\n * Given an SPE.Shader attribute instance, and various other settings,\n * assign Color values to the attribute.\n * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n * @param  {Object} base      THREE.Color instance describing the start color.\n * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n */\nexport function randomColor( attribute, index, base, spread ) {\n    let r = base.r + ( Math.random() * spread.x ),\n        g = base.g + ( Math.random() * spread.y ),\n        b = base.b + ( Math.random() * spread.z );\n\n    r = clamp( r, 0, 1 );\n    g = clamp( g, 0, 1 );\n    b = clamp( b, 0, 1 );\n\n    attribute.typedArray.setVec3Components( index, r, g, b );\n};\n\n\nexport const randomColorAsHex = ( function() {\n    const workingColor = new THREEColor();\n\n    /**\n     * Assigns a random color value, encoded as a hex value in decimal\n     * format, to a SPE.ShaderAttribute instance.\n     * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n     * @param  {Object} base      THREE.Color instance describing the start color.\n     * @param  {Object} spread    THREE.Vector3 instance describing the random variance to apply to the start color.\n     */\n    return function( attribute, index, base, spread ) {\n        const numItems = base.length,\n            colors = [];\n\n        for ( let i = 0; i < numItems; ++i ) {\n            const spreadVector = spread[ i ];\n\n            workingColor.copy( base[ i ] );\n\n            workingColor.r += ( Math.random() * spreadVector.x ) - ( spreadVector.x * 0.5 );\n            workingColor.g += ( Math.random() * spreadVector.y ) - ( spreadVector.y * 0.5 );\n            workingColor.b += ( Math.random() * spreadVector.z ) - ( spreadVector.z * 0.5 );\n\n            workingColor.r = clamp( workingColor.r, 0, 1 );\n            workingColor.g = clamp( workingColor.g, 0, 1 );\n            workingColor.b = clamp( workingColor.b, 0, 1 );\n\n            colors.push( workingColor.getHex() );\n        }\n\n        attribute.typedArray.setVec4Components(\n            index,\n            colors[ 0 ],\n            colors[ 1 ],\n            colors[ 2 ],\n            colors[ 3 ]\n        );\n    };\n}() );\n\n/**\n * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the\n * given values onto a sphere.\n *\n * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.\n * @param  {Number} radius            The radius of the sphere to project onto.\n * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result\n * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the sphere.\n * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.\n */\nexport function randomVector3OnSphere(\n    attribute,\n    index,\n    base,\n    radius,\n    radiusSpread,\n    radiusScale,\n    radiusSpreadClamp,\n    distributionClamp\n) {\n    var depth = 2 * Math.random() - 1,\n        t = 6.2832 * Math.random(),\n        r = Math.sqrt( 1 - depth * depth ),\n        rand = randomFloat( radius, radiusSpread ),\n        x = 0,\n        y = 0,\n        z = 0;\n\n\n    if ( radiusSpreadClamp ) {\n        rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n    }\n\n\n\n    // Set position on sphere\n    x = r * Math.cos( t ) * rand;\n    y = r * Math.sin( t ) * rand;\n    z = depth * rand;\n\n    // Apply radius scale to this position\n    x *= radiusScale.x;\n    y *= radiusScale.y;\n    z *= radiusScale.z;\n\n    // Translate to the base position.\n    x += base.x;\n    y += base.y;\n    z += base.z;\n\n    // Set the values in the typed array.\n    attribute.typedArray.setVec3Components( index, x, y, z );\n};\n\nexport function seededRandom( seed ) {\n    const x = Math.sin( seed ) * 10000;\n    return x - ( x | 0 );\n};\n\n\n\n/**\n * Assigns a random vector 3 value to an SPE.ShaderAttribute instance, projecting the\n * given values onto a 2d-disc.\n *\n * @param  {Object} attribute The instance of SPE.ShaderAttribute to save the result to.\n * @param  {Number} index     The offset in the attribute's TypedArray to save the result from.\n * @param  {Object} base              THREE.Vector3 instance describing the origin of the transform.\n * @param  {Number} radius            The radius of the sphere to project onto.\n * @param  {Number} radiusSpread      The amount of randomness to apply to the projection result\n * @param  {Object} radiusScale       THREE.Vector3 instance describing the scale of each axis of the disc. The z-component is ignored.\n * @param  {Number} radiusSpreadClamp What numeric multiple the projected value should be clamped to.\n */\nexport function randomVector3OnDisc(\n    attribute,\n    index, base,\n    radius,\n    radiusSpread,\n    radiusScale,\n    radiusSpreadClamp\n) {\n    const t = 6.2832 * Math.random();\n    let rand = Math.abs( randomFloat( radius, radiusSpread ) );\n\n    let x = 0,\n        y = 0,\n        z = 0;\n\n    if ( radiusSpreadClamp ) {\n        rand = Math.round( rand / radiusSpreadClamp ) * radiusSpreadClamp;\n    }\n\n    // Set position on sphere\n    x = Math.cos( t ) * rand;\n    y = Math.sin( t ) * rand;\n\n    // Apply radius scale to this position\n    x *= radiusScale.x;\n    y *= radiusScale.y;\n\n    // Translate to the base position.\n    x += base.x;\n    y += base.y;\n    z += base.z;\n\n    // Set the values in the typed array.\n    attribute.typedArray.setVec3Components( index, x, y, z );\n};\n\nexport const randomDirectionVector3OnSphere = ( function() {\n    const v = new THREEVector3();\n\n    /**\n     * Given an SPE.ShaderAttribute instance, create a direction vector from the given\n     * position, using `speed` as the magnitude. Values are saved to the attribute.\n     *\n     * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.\n     * @param  {Number} posX            The particle's x coordinate.\n     * @param  {Number} posY            The particle's y coordinate.\n     * @param  {Number} posZ            The particle's z coordinate.\n     * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.\n     * @param  {Number} speed           The magnitude to apply to the vector.\n     * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.\n     */\n    return function(\n        attribute,\n        index,\n        posX,\n        posY,\n        posZ,\n        emitterPosition,\n        speed,\n        speedSpread\n    ) {\n        v.copy( emitterPosition );\n\n        v.x -= posX;\n        v.y -= posY;\n        v.z -= posZ;\n\n        v.normalize().multiplyScalar( -randomFloat( speed, speedSpread ) );\n\n        attribute.typedArray.setVec3Components( index, v.x, v.y, v.z );\n    };\n}() );\n\nexport const randomDirectionVector3OnDisc = ( function() {\n    const v = new THREEVector3();\n\n    /**\n     * Given an SPE.ShaderAttribute instance, create a direction vector from the given\n     * position, using `speed` as the magnitude. Values are saved to the attribute.\n     *\n     * @param  {Object} attribute       The instance of SPE.ShaderAttribute to save the result to.\n     * @param  {Number} index           The offset in the attribute's TypedArray to save the result from.\n     * @param  {Number} posX            The particle's x coordinate.\n     * @param  {Number} posY            The particle's y coordinate.\n     * @param  {Number} posZ            The particle's z coordinate.\n     * @param  {Object} emitterPosition THREE.Vector3 instance describing the emitter's base position.\n     * @param  {Number} speed           The magnitude to apply to the vector.\n     * @param  {Number} speedSpread     The amount of randomness to apply to the magnitude.\n     */\n    return function(\n        attribute,\n        index,\n        posX,\n        posY,\n        posZ,\n        emitterPosition,\n        speed,\n        speedSpread\n    ) {\n        v.copy( emitterPosition );\n\n        v.x -= posX;\n        v.y -= posY;\n        v.z -= posZ;\n\n        v.normalize().multiplyScalar( -randomFloat( speed, speedSpread ) );\n\n        attribute.typedArray.setVec3Components( index, v.x, v.y, 0 );\n    };\n}() );\n\nexport const getPackedRotationAxis = ( function() {\n    const v = new THREEVector3(),\n        vSpread = new THREEVector3(),\n        c = new THREEColor(),\n        addOne = new THREEVector3( 1, 1, 1 );\n\n    /**\n     * Given a rotation axis, and a rotation axis spread vector,\n     * calculate a randomised rotation axis, and pack it into\n     * a hexadecimal value represented in decimal form.\n     * @param  {Object} axis       THREE.Vector3 instance describing the rotation axis.\n     * @param  {Object} axisSpread THREE.Vector3 instance describing the amount of randomness to apply to the rotation axis.\n     * @return {Number}            The packed rotation axis, with randomness.\n     */\n    return function( axis, axisSpread ) {\n        v.copy( axis ).normalize();\n        vSpread.copy( axisSpread ).normalize();\n\n        v.x += ( -axisSpread.x * 0.5 ) + ( Math.random() * axisSpread.x );\n        v.y += ( -axisSpread.y * 0.5 ) + ( Math.random() * axisSpread.y );\n        v.z += ( -axisSpread.z * 0.5 ) + ( Math.random() * axisSpread.z );\n\n        // v.x = Math.abs( v.x );\n        // v.y = Math.abs( v.y );\n        // v.z = Math.abs( v.z );\n\n        v.normalize().add( addOne ).multiplyScalar( 0.5 );\n\n        c.setRGB( v.x, v.y, v.z );\n\n        return c.getHex();\n    };\n}() );","import {\n    types,\n    ensureTypedArg,\n    ensureArrayTypedArg,\n    ensureInstanceOf,\n    ensureValueOverLifetimeCompliance,\n    ensureArrayInstanceOf,\n    randomVector3,\n    randomVector3OnSphere,\n    randomVector3OnDisc,\n    randomDirectionVector3OnSphere,\n    randomDirectionVector3OnDisc,\n    clamp,\n    randomFloat,\n    arrayValuesAreEqual,\n    getPackedRotationAxis,\n    randomColorAsHex\n} from './utils';\nimport { valueOverLifetimeLength, distributions } from '../constants';\n\nimport { Math as THREEMath } from 'three';\nimport { Vector3 as THREEVector3 } from 'three';\nimport { Color as THREEColor } from 'three';\n\n/**\n * An SPE.Emitter instance.\n * @typedef {Object} Emitter\n * @see SPE.Emitter\n */\n\n/**\n * A map of options to configure an SPE.Emitter instance.\n *\n * @typedef {Object} EmitterOptions\n *\n * @property {distribution} [type=BOX] The default distribution this emitter should use to control\n *                         its particle's spawn position and force behaviour.\n *                         Must be an SPE.distributions.* value.\n *\n *\n * @property {Number} [particleCount=100] The total number of particles this emitter will hold. NOTE: this is not the number\n *                                  of particles emitted in a second, or anything like that. The number of particles\n *                                  emitted per-second is calculated by particleCount / maxAge (approximately!)\n *\n * @property {Number|null} [duration=null] The duration in seconds that this emitter should live for. If not specified, the emitter\n *                                         will emit particles indefinitely.\n *                                         NOTE: When an emitter is older than a specified duration, the emitter is NOT removed from\n *                                         it's group, but rather is just marked as dead, allowing it to be reanimated at a later time\n *                                         using `SPE.Emitter.prototype.enable()`.\n *\n * @property {Boolean} [isStatic=false] Whether this emitter should be not be simulated (true).\n * @property {Boolean} [activeMultiplier=1] A value between 0 and 1 describing what percentage of this emitter's particlesPerSecond should be\n *                                          emitted, where 0 is 0%, and 1 is 100%.\n *                                          For example, having an emitter with 100 particles, a maxAge of 2, yields a particlesPerSecond\n *                                          value of 50. Setting `activeMultiplier` to 0.5, then, will only emit 25 particles per second (0.5 = 50%).\n *                                          Values greater than 1 will emulate a burst of particles, causing the emitter to run out of particles\n *                                          before it's next activation cycle.\n *\n * @property {Boolean} [direction=1] The direction of the emitter. If value is `1`, emitter will start at beginning of particle's lifecycle.\n *                                   If value is `-1`, emitter will start at end of particle's lifecycle and work it's way backwards.\n *\n * @property {Object} [maxAge={}] An object describing the particle's maximum age in seconds.\n * @property {Number} [maxAge.value=2] A number between 0 and 1 describing the amount of maxAge to apply to all particles.\n * @property {Number} [maxAge.spread=0] A number describing the maxAge variance on a per-particle basis.\n *\n *\n * @property {Object} [position={}] An object describing this emitter's position.\n * @property {Object} [position.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base position.\n * @property {Object} [position.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's position variance on a per-particle basis.\n *                                                          Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                          of this vector is used.\n * @property {Object} [position.spreadClamp=new THREE.Vector3()] A THREE.Vector3 instance describing the numeric multiples the particle's should\n *                                                               be spread out over.\n *                                                               Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                               of this vector is used.\n * @property {Number} [position.radius=10] This emitter's base radius.\n * @property {Object} [position.radiusScale=new THREE.Vector3()] A THREE.Vector3 instance describing the radius's scale in all three axes. Allows a SPHERE or DISC to be squashed or stretched.\n * @property {distribution} [position.distribution=value of the `type` option.] A specific distribution to use when radiusing particles. Overrides the `type` option.\n * @property {Boolean} [position.randomise=false] When a particle is re-spawned, whether it's position should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [velocity={}] An object describing this particle velocity.\n * @property {Object} [velocity.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base velocity.\n * @property {Object} [velocity.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's velocity variance on a per-particle basis.\n *                                                          Note that when using a SPHERE or DISC distribution, only the x-component\n *                                                          of this vector is used.\n * @property {distribution} [velocity.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's velocity. Overrides the `type` option.\n * @property {Boolean} [velocity.randomise=false] When a particle is re-spawned, whether it's velocity should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [acceleration={}] An object describing this particle's acceleration.\n * @property {Object} [acceleration.value=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's base acceleration.\n * @property {Object} [acceleration.spread=new THREE.Vector3()] A THREE.Vector3 instance describing this emitter's acceleration variance on a per-particle basis.\n *                           Note that when using a SPHERE or DISC distribution, only the x-component\n *                           of this vector is used.\n * @property {distribution} [acceleration.distribution=value of the `type` option.] A specific distribution to use when calculating a particle's acceleration. Overrides the `type` option.\n * @property {Boolean} [acceleration.randomise=false] When a particle is re-spawned, whether it's acceleration should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [drag={}] An object describing this particle drag. Drag is applied to both velocity and acceleration values.\n * @property {Number} [drag.value=0] A number between 0 and 1 describing the amount of drag to apply to all particles.\n * @property {Number} [drag.spread=0] A number describing the drag variance on a per-particle basis.\n * @property {Boolean} [drag.randomise=false] When a particle is re-spawned, whether it's drag should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [wiggle={}] This is quite a fun one! The values of this object will determine whether a particle will wiggle, or jiggle, or wave,\n *                                or shimmy, or waggle, or... Well you get the idea. The wiggle is calculated over-time, meaning that a particle will\n *                                start off with no wiggle, and end up wiggling about with the distance of the `value` specified by the time it dies.\n *                                It's quite handy to simulate fire embers, or similar effects where the particle's position should slightly change over\n *                                time, and such change isn't easily controlled by rotation, velocity, or acceleration. The wiggle is a combination of sin and cos calculations, so is circular in nature.\n * @property {Number} [wiggle.value=0] A number describing the amount of wiggle to apply to all particles. It's measured in distance.\n * @property {Number} [wiggle.spread=0] A number describing the wiggle variance on a per-particle basis.\n *\n *\n * @property {Object} [rotation={}] An object describing this emitter's rotation. It can either be static, or set to rotate from 0radians to the value of `rotation.value`\n *                                  over a particle's lifetime. Rotation values affect both a particle's position and the forces applied to it.\n * @property {Object} [rotation.axis=new THREE.Vector3(0, 1, 0)] A THREE.Vector3 instance describing this emitter's axis of rotation.\n * @property {Object} [rotation.axisSpread=new THREE.Vector3()] A THREE.Vector3 instance describing the amount of variance to apply to the axis of rotation on\n *                                                              a per-particle basis.\n * @property {Number} [rotation.angle=0] The angle of rotation, given in radians. If `rotation.static` is true, the emitter will start off rotated at this angle, and stay as such.\n *                                       Otherwise, the particles will rotate from 0radians to this value over their lifetimes.\n * @property {Number} [rotation.angleSpread=0] The amount of variance in each particle's rotation angle.\n * @property {Boolean} [rotation.static=false] Whether the rotation should be static or not.\n * @property {Object} [rotation.center=The value of `position.value`] A THREE.Vector3 instance describing the center point of rotation.\n * @property {Boolean} [rotation.randomise=false] When a particle is re-spawned, whether it's rotation should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [color={}] An object describing a particle's color. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of THREE.Color instances are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Object} [color.value=new THREE.Color()] Either a single THREE.Color instance, or an array of THREE.Color instances to describe the color of a particle over it's lifetime.\n * @property {Object} [color.spread=new THREE.Vector3()] Either a single THREE.Vector3 instance, or an array of THREE.Vector3 instances to describe the color variance of a particle over it's lifetime.\n * @property {Boolean} [color.randomise=false] When a particle is re-spawned, whether it's color should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [opacity={}] An object describing a particle's opacity. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [opacity.value=1] Either a single number, or an array of numbers to describe the opacity of a particle over it's lifetime.\n * @property {Number} [opacity.spread=0] Either a single number, or an array of numbers to describe the opacity variance of a particle over it's lifetime.\n * @property {Boolean} [opacity.randomise=false] When a particle is re-spawned, whether it's opacity should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [size={}] An object describing a particle's size. This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [size.value=1] Either a single number, or an array of numbers to describe the size of a particle over it's lifetime.\n * @property {Number} [size.spread=0] Either a single number, or an array of numbers to describe the size variance of a particle over it's lifetime.\n * @property {Boolean} [size.randomise=false] When a particle is re-spawned, whether it's size should be re-randomised or not. Can incur a performance hit.\n *\n *\n * @property {Object} [angle={}] An object describing a particle's angle. The angle is a 2d-rotation, measured in radians, applied to the particle's texture.\n *                               NOTE: if a particle's texture is a sprite-sheet, this value IS IGNORED.\n *                               This property is a \"value-over-lifetime\" property, meaning an array of values and spreads can be\n *                               given to describe specific value changes over a particle's lifetime.\n *                               Depending on the value of SPE.valueOverLifetimeLength, if arrays of numbers are given, then the array will be interpolated to\n *                               have a length matching the value of SPE.valueOverLifetimeLength.\n * @property {Number} [angle.value=0] Either a single number, or an array of numbers to describe the angle of a particle over it's lifetime.\n * @property {Number} [angle.spread=0] Either a single number, or an array of numbers to describe the angle variance of a particle over it's lifetime.\n * @property {Boolean} [angle.randomise=false] When a particle is re-spawned, whether it's angle should be re-randomised or not. Can incur a performance hit.\n *\n */\n\n/**\n * The SPE.Emitter class.\n *\n * @constructor\n *\n * @param {EmitterOptions} options A map of options to configure the emitter.\n */\nexport default class Emitter {\n    constructor( options = {} ) {\n        const lifetimeLength = valueOverLifetimeLength;\n\n        // Ensure we have a map of options to play with,\n        // and that each option is in the correct format.\n        options.position = ensureTypedArg( options.position, types.OBJECT, {} );\n        options.velocity = ensureTypedArg( options.velocity, types.OBJECT, {} );\n        options.acceleration = ensureTypedArg( options.acceleration, types.OBJECT, {} );\n        options.radius = ensureTypedArg( options.radius, types.OBJECT, {} );\n        options.drag = ensureTypedArg( options.drag, types.OBJECT, {} );\n        options.rotation = ensureTypedArg( options.rotation, types.OBJECT, {} );\n        options.color = ensureTypedArg( options.color, types.OBJECT, {} );\n        options.opacity = ensureTypedArg( options.opacity, types.OBJECT, {} );\n        options.size = ensureTypedArg( options.size, types.OBJECT, {} );\n        options.angle = ensureTypedArg( options.angle, types.OBJECT, {} );\n        options.wiggle = ensureTypedArg( options.wiggle, types.OBJECT, {} );\n        options.maxAge = ensureTypedArg( options.maxAge, types.OBJECT, {} );\n\n        if ( options.onParticleSpawn ) {\n            console.warn( 'onParticleSpawn has been removed. Please set properties directly to alter values at runtime.' );\n        }\n\n        this.uuid = THREEMath.generateUUID();\n\n        this.type = ensureTypedArg( options.type, types.NUMBER, distributions.BOX );\n\n        // Start assigning properties...kicking it off with props that DON'T support values over\n        // lifetimes.\n        //\n        // Btw, values over lifetimes are just the new way of referring to *Start, *Middle, and *End.\n        this.position = {\n            _value: ensureInstanceOf( options.position.value, THREEVector3, new THREEVector3() ),\n            _spread: ensureInstanceOf( options.position.spread, THREEVector3, new THREEVector3() ),\n            _spreadClamp: ensureInstanceOf( options.position.spreadClamp, THREEVector3, new THREEVector3() ),\n            _distribution: ensureTypedArg( options.position.distribution, types.NUMBER, this.type ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false ),\n            _radius: ensureTypedArg( options.position.radius, types.NUMBER, 10 ),\n            _radiusScale: ensureInstanceOf( options.position.radiusScale, THREEVector3, new THREEVector3( 1, 1, 1 ) ),\n            _distributionClamp: ensureTypedArg( options.position.distributionClamp, types.NUMBER, 0 ),\n        };\n\n        this.velocity = {\n            _value: ensureInstanceOf( options.velocity.value, THREEVector3, new THREEVector3() ),\n            _spread: ensureInstanceOf( options.velocity.spread, THREEVector3, new THREEVector3() ),\n            _distribution: ensureTypedArg( options.velocity.distribution, types.NUMBER, this.type ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n        };\n\n        this.acceleration = {\n            _value: ensureInstanceOf( options.acceleration.value, THREEVector3, new THREEVector3() ),\n            _spread: ensureInstanceOf( options.acceleration.spread, THREEVector3, new THREEVector3() ),\n            _distribution: ensureTypedArg( options.acceleration.distribution, types.NUMBER, this.type ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n        };\n\n        this.drag = {\n            _value: ensureTypedArg( options.drag.value, types.NUMBER, 0 ),\n            _spread: ensureTypedArg( options.drag.spread, types.NUMBER, 0 ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n        };\n\n        this.wiggle = {\n            _value: ensureTypedArg( options.wiggle.value, types.NUMBER, 0 ),\n            _spread: ensureTypedArg( options.wiggle.spread, types.NUMBER, 0 )\n        };\n\n        this.rotation = {\n            _axis: ensureInstanceOf( options.rotation.axis, THREEVector3, new THREEVector3( 0.0, 1.0, 0.0 ) ),\n            _axisSpread: ensureInstanceOf( options.rotation.axisSpread, THREEVector3, new THREEVector3() ),\n            _angle: ensureTypedArg( options.rotation.angle, types.NUMBER, 0 ),\n            _angleSpread: ensureTypedArg( options.rotation.angleSpread, types.NUMBER, 0 ),\n            _static: ensureTypedArg( options.rotation.static, types.BOOLEAN, false ),\n            _center: ensureInstanceOf( options.rotation.center, THREEVector3, this.position._value.clone() ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n        };\n\n\n        this.maxAge = {\n            _value: ensureTypedArg( options.maxAge.value, types.NUMBER, 2 ),\n            _spread: ensureTypedArg( options.maxAge.spread, types.NUMBER, 0 )\n        };\n\n\n\n        // The following properties can support either single values, or an array of values that change\n        // the property over a particle's lifetime (value over lifetime).\n        this.color = {\n            _value: ensureArrayInstanceOf( options.color.value, THREEColor, new THREEColor() ),\n            _spread: ensureArrayInstanceOf( options.color.spread, THREEVector3, new THREEVector3() ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n        };\n\n        this.opacity = {\n            _value: ensureArrayTypedArg( options.opacity.value, types.NUMBER, 1 ),\n            _spread: ensureArrayTypedArg( options.opacity.spread, types.NUMBER, 0 ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n        };\n\n        this.size = {\n            _value: ensureArrayTypedArg( options.size.value, types.NUMBER, 1 ),\n            _spread: ensureArrayTypedArg( options.size.spread, types.NUMBER, 0 ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n        };\n\n        this.angle = {\n            _value: ensureArrayTypedArg( options.angle.value, types.NUMBER, 0 ),\n            _spread: ensureArrayTypedArg( options.angle.spread, types.NUMBER, 0 ),\n            _randomise: ensureTypedArg( options.position.randomise, types.BOOLEAN, false )\n        };\n\n\n        // Assign renaining option values.\n        this.particleCount = ensureTypedArg( options.particleCount, types.NUMBER, 100 );\n        this.duration = ensureTypedArg( options.duration, types.NUMBER, null );\n        this.isStatic = ensureTypedArg( options.isStatic, types.BOOLEAN, false );\n        this.activeMultiplier = ensureTypedArg( options.activeMultiplier, types.NUMBER, 1 );\n        this.direction = ensureTypedArg( options.direction, types.NUMBER, 1 );\n\n        // Whether this emitter is alive or not.\n        this.alive = ensureTypedArg( options.alive, types.BOOLEAN, true );\n\n\n        // The following properties are set internally and are not\n        // user-controllable.\n        this.particlesPerSecond = 0;\n\n        // The current particle index for which particles should\n        // be marked as active on the next update cycle.\n        this.activationIndex = 0;\n\n        // The offset in the typed arrays this emitter's\n        // particle's values will start at\n        this.attributeOffset = 0;\n\n        // The end of the range in the attribute buffers\n        this.attributeEnd = 0;\n\n\n\n        // Holds the time the emitter has been alive for.\n        this.age = 0.0;\n\n        // Holds the number of currently-alive particles\n        this.activeParticleCount = 0.0;\n\n        // Holds a reference to this emitter's group once\n        // it's added to one.\n        this.group = null;\n\n        // Holds a reference to this emitter's group's attributes object\n        // for easier access.\n        this.attributes = null;\n\n        // Holds a reference to the params attribute's typed array\n        // for quicker access.\n        this.paramsArray = null;\n\n        // A set of flags to determine whether particular properties\n        // should be re-randomised when a particle is reset.\n        //\n        // If a `randomise` property is given, this is preferred.\n        // Otherwise, it looks at whether a spread value has been\n        // given.\n        //\n        // It allows randomization to be turned off as desired. If\n        // all randomization is turned off, then I'd expect a performance\n        // boost as no attribute buffers (excluding the `params`)\n        // would have to be re-passed to the GPU each frame (since nothing\n        // except the `params` attribute would have changed).\n        this.resetFlags = {\n            // params: ensureTypedArg( options.maxAge.randomise, types.BOOLEAN, !!options.maxAge.spread ) ||\n            //     ensureTypedArg( options.wiggle.randomise, types.BOOLEAN, !!options.wiggle.spread ),\n            position: ensureTypedArg( options.position.randomise, types.BOOLEAN, false ) ||\n                ensureTypedArg( options.radius.randomise, types.BOOLEAN, false ),\n            velocity: ensureTypedArg( options.velocity.randomise, types.BOOLEAN, false ),\n            acceleration: ensureTypedArg( options.acceleration.randomise, types.BOOLEAN, false ) ||\n                ensureTypedArg( options.drag.randomise, types.BOOLEAN, false ),\n            rotation: ensureTypedArg( options.rotation.randomise, types.BOOLEAN, false ),\n            rotationCenter: ensureTypedArg( options.rotation.randomise, types.BOOLEAN, false ),\n            size: ensureTypedArg( options.size.randomise, types.BOOLEAN, false ),\n            color: ensureTypedArg( options.color.randomise, types.BOOLEAN, false ),\n            opacity: ensureTypedArg( options.opacity.randomise, types.BOOLEAN, false ),\n            angle: ensureTypedArg( options.angle.randomise, types.BOOLEAN, false )\n        };\n\n        this.updateFlags = {};\n        this.updateCounts = {};\n\n        // A map to indicate which emitter parameters should update\n        // which attribute.\n        this.updateMap = {\n            maxAge: 'params',\n            position: 'position',\n            velocity: 'velocity',\n            acceleration: 'acceleration',\n            drag: 'acceleration',\n            wiggle: 'params',\n            rotation: 'rotation',\n            size: 'size',\n            color: 'color',\n            opacity: 'opacity',\n            angle: 'angle'\n        };\n\n        for ( var i in this.updateMap ) {\n            if ( this.updateMap.hasOwnProperty( i ) ) {\n                this.updateCounts[ this.updateMap[ i ] ] = 0.0;\n                this.updateFlags[ this.updateMap[ i ] ] = false;\n                this._createGetterSetters( this[ i ], i );\n            }\n        }\n\n        this.bufferUpdateRanges = {};\n        this.attributeKeys = null;\n        this.attributeCount = 0;\n\n\n        // Ensure that the value-over-lifetime property objects above\n        // have value and spread properties that are of the same length.\n        //\n        // Also, for now, make sure they have a length of 3 (min/max arguments here).\n        ensureValueOverLifetimeCompliance( this.color, lifetimeLength, lifetimeLength );\n        ensureValueOverLifetimeCompliance( this.opacity, lifetimeLength, lifetimeLength );\n        ensureValueOverLifetimeCompliance( this.size, lifetimeLength, lifetimeLength );\n        ensureValueOverLifetimeCompliance( this.angle, lifetimeLength, lifetimeLength );\n    }\n\n    _createGetterSetters( propObj, propName ) {\n        var self = this;\n\n        for ( var i in propObj ) {\n            if ( propObj.hasOwnProperty( i ) ) {\n\n                var name = i.replace( '_', '' );\n\n                Object.defineProperty( propObj, name, {\n                    get: ( function( prop ) {\n                        return function() {\n                            return this[ prop ];\n                        };\n                    }( i ) ),\n\n                    set: ( function( prop ) {\n                        return function( value ) {\n                            var mapName = self.updateMap[ propName ],\n                                prevValue = this[ prop ],\n                                length = valueOverLifetimeLength;\n\n                            if ( prop === '_rotationCenter' ) {\n                                self.updateFlags.rotationCenter = true;\n                                self.updateCounts.rotationCenter = 0.0;\n                            }\n                            else if ( prop === '_randomise' ) {\n                                self.resetFlags[ mapName ] = value;\n                            }\n                            else {\n                                self.updateFlags[ mapName ] = true;\n                                self.updateCounts[ mapName ] = 0.0;\n                            }\n\n                            self.group._updateDefines();\n\n                            this[ prop ] = value;\n\n                            // If the previous value was an array, then make\n                            // sure the provided value is interpolated correctly.\n                            if ( Array.isArray( prevValue ) ) {\n                                ensureValueOverLifetimeCompliance( self[ propName ], length, length );\n                            }\n                        };\n                    }( i ) )\n                } );\n            }\n        }\n    }\n\n    _setBufferUpdateRanges( keys ) {\n        this.attributeKeys = keys;\n        this.attributeCount = keys.length;\n\n        for ( var i = this.attributeCount - 1; i >= 0; --i ) {\n            this.bufferUpdateRanges[ keys[ i ] ] = {\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY\n            };\n        }\n    }\n\n    _calculatePPSValue( groupMaxAge ) {\n        var particleCount = this.particleCount;\n\n\n        // Calculate the `particlesPerSecond` value for this emitter. It's used\n        // when determining which particles should die and which should live to\n        // see another day. Or be born, for that matter. The \"God\" property.\n        if ( this.duration ) {\n            this.particlesPerSecond = particleCount / ( groupMaxAge < this.duration ? groupMaxAge : this.duration );\n        }\n        else {\n            this.particlesPerSecond = particleCount / groupMaxAge;\n        }\n    }\n\n    _setAttributeOffset( startIndex ) {\n        this.attributeOffset = startIndex;\n        this.activationIndex = startIndex;\n        this.activationEnd = startIndex + this.particleCount;\n    }\n\n\n    _assignValue( prop, index ) {\n        switch ( prop ) {\n            case 'position':\n                this._assignPositionValue( index );\n                break;\n\n            case 'velocity':\n            case 'acceleration':\n                this._assignForceValue( index, prop );\n                break;\n\n            case 'size':\n            case 'opacity':\n                this._assignAbsLifetimeValue( index, prop );\n                break;\n\n            case 'angle':\n                this._assignAngleValue( index );\n                break;\n\n            case 'params':\n                this._assignParamsValue( index );\n                break;\n\n            case 'rotation':\n                this._assignRotationValue( index );\n                break;\n\n            case 'color':\n                this._assignColorValue( index );\n                break;\n        }\n    }\n\n    _assignPositionValue( index ) {\n        var distributions = SPE.distributions,\n            utils = utils,\n            prop = this.position,\n            attr = this.attributes.position,\n            value = prop._value,\n            spread = prop._spread,\n            distribution = prop._distribution;\n\n        switch ( distribution ) {\n            case distributions.BOX:\n                randomVector3( attr, index, value, spread, prop._spreadClamp );\n                break;\n\n            case distributions.SPHERE:\n                randomVector3OnSphere( attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x, prop._distributionClamp || this.particleCount );\n                break;\n\n            case distributions.DISC:\n                randomVector3OnDisc( attr, index, value, prop._radius, prop._spread.x, prop._radiusScale, prop._spreadClamp.x );\n                break;\n        }\n    }\n\n    _assignForceValue( index, attrName ) {\n        var distributions = SPE.distributions,\n            utils = utils,\n            prop = this[ attrName ],\n            value = prop._value,\n            spread = prop._spread,\n            distribution = prop._distribution,\n            pos,\n            positionX,\n            positionY,\n            positionZ,\n            i;\n\n        switch ( distribution ) {\n            case distributions.BOX:\n                randomVector3( this.attributes[ attrName ], index, value, spread );\n                break;\n\n            case distributions.SPHERE:\n                pos = this.attributes.position.typedArray.array;\n                i = index * 3;\n\n                // Ensure position values aren't zero, otherwise no force will be\n                // applied.\n                // positionX = zeroToEpsilon( pos[ i ], true );\n                // positionY = zeroToEpsilon( pos[ i + 1 ], true );\n                // positionZ = zeroToEpsilon( pos[ i + 2 ], true );\n                positionX = pos[ i ];\n                positionY = pos[ i + 1 ];\n                positionZ = pos[ i + 2 ];\n\n                randomDirectionVector3OnSphere(\n                    this.attributes[ attrName ], index,\n                    positionX, positionY, positionZ,\n                    this.position._value,\n                    prop._value.x,\n                    prop._spread.x\n                );\n                break;\n\n            case distributions.DISC:\n                pos = this.attributes.position.typedArray.array;\n                i = index * 3;\n\n                // Ensure position values aren't zero, otherwise no force will be\n                // applied.\n                // positionX = zeroToEpsilon( pos[ i ], true );\n                // positionY = zeroToEpsilon( pos[ i + 1 ], true );\n                // positionZ = zeroToEpsilon( pos[ i + 2 ], true );\n                positionX = pos[ i ];\n                positionY = pos[ i + 1 ];\n                positionZ = pos[ i + 2 ];\n\n                randomDirectionVector3OnDisc(\n                    this.attributes[ attrName ], index,\n                    positionX, positionY, positionZ,\n                    this.position._value,\n                    prop._value.x,\n                    prop._spread.x\n                );\n                break;\n        }\n\n        if ( attrName === 'acceleration' ) {\n            var drag = clamp( randomFloat( this.drag._value, this.drag._spread ), 0, 1 );\n            this.attributes.acceleration.typedArray.array[ index * 4 + 3 ] = drag;\n        }\n    }\n\n    _assignAbsLifetimeValue( index, propName ) {\n        var array = this.attributes[ propName ].typedArray,\n            prop = this[ propName ],\n            utils = utils,\n            value;\n\n        if ( arrayValuesAreEqual( prop._value ) && arrayValuesAreEqual( prop._spread ) ) {\n            value = Math.abs( randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ) );\n            array.setVec4Components( index, value, value, value, value );\n        }\n        else {\n            array.setVec4Components( index,\n                Math.abs( randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ) ),\n                Math.abs( randomFloat( prop._value[ 1 ], prop._spread[ 1 ] ) ),\n                Math.abs( randomFloat( prop._value[ 2 ], prop._spread[ 2 ] ) ),\n                Math.abs( randomFloat( prop._value[ 3 ], prop._spread[ 3 ] ) )\n            );\n        }\n    }\n\n    _assignAngleValue( index ) {\n        var array = this.attributes.angle.typedArray,\n            prop = this.angle,\n            utils = utils,\n            value;\n\n        if ( arrayValuesAreEqual( prop._value ) && arrayValuesAreEqual( prop._spread ) ) {\n            value = randomFloat( prop._value[ 0 ], prop._spread[ 0 ] );\n            array.setVec4Components( index, value, value, value, value );\n        }\n        else {\n            array.setVec4Components( index,\n                randomFloat( prop._value[ 0 ], prop._spread[ 0 ] ),\n                randomFloat( prop._value[ 1 ], prop._spread[ 1 ] ),\n                randomFloat( prop._value[ 2 ], prop._spread[ 2 ] ),\n                randomFloat( prop._value[ 3 ], prop._spread[ 3 ] )\n            );\n        }\n    }\n\n    _assignParamsValue( index ) {\n        this.attributes.params.typedArray.setVec4Components( index,\n            this.isStatic ? 1 : 0,\n            0.0,\n            Math.abs( randomFloat( this.maxAge._value, this.maxAge._spread ) ),\n            randomFloat( this.wiggle._value, this.wiggle._spread )\n        );\n    }\n\n    _assignRotationValue( index ) {\n        this.attributes.rotation.typedArray.setVec3Components( index,\n            getPackedRotationAxis( this.rotation._axis, this.rotation._axisSpread ),\n            randomFloat( this.rotation._angle, this.rotation._angleSpread ),\n            this.rotation._static ? 0 : 1\n        );\n\n        this.attributes.rotationCenter.typedArray.setVec3( index, this.rotation._center );\n    }\n\n    _assignColorValue( index ) {\n        randomColorAsHex( this.attributes.color, index, this.color._value, this.color._spread );\n    }\n\n    _resetParticle( index ) {\n        var resetFlags = this.resetFlags,\n            updateFlags = this.updateFlags,\n            updateCounts = this.updateCounts,\n            keys = this.attributeKeys,\n            key,\n            updateFlag;\n\n        for ( var i = this.attributeCount - 1; i >= 0; --i ) {\n            key = keys[ i ];\n            updateFlag = updateFlags[ key ];\n\n            if ( resetFlags[ key ] === true || updateFlag === true ) {\n                this._assignValue( key, index );\n                this._updateAttributeUpdateRange( key, index );\n\n                if ( updateFlag === true && updateCounts[ key ] === this.particleCount ) {\n                    updateFlags[ key ] = false;\n                    updateCounts[ key ] = 0.0;\n                }\n                else if ( updateFlag == true ) {\n                    ++updateCounts[ key ];\n                }\n            }\n        }\n    }\n\n    _updateAttributeUpdateRange( attr, i ) {\n        var ranges = this.bufferUpdateRanges[ attr ];\n\n        ranges.min = Math.min( i, ranges.min );\n        ranges.max = Math.max( i, ranges.max );\n    }\n\n    _resetBufferRanges() {\n        var ranges = this.bufferUpdateRanges,\n            keys = this.bufferUpdateKeys,\n            i = this.bufferUpdateCount - 1,\n            key;\n\n        for ( i; i >= 0; --i ) {\n            key = keys[ i ];\n            ranges[ key ].min = Number.POSITIVE_INFINITY;\n            ranges[ key ].max = Number.NEGATIVE_INFINITY;\n        }\n    }\n\n    _onRemove() {\n        // Reset any properties of the emitter that were set by\n        // a group when it was added.\n        this.particlesPerSecond = 0;\n        this.attributeOffset = 0;\n        this.activationIndex = 0;\n        this.activeParticleCount = 0;\n        this.group = null;\n        this.attributes = null;\n        this.paramsArray = null;\n        this.age = 0.0;\n    }\n\n    _decrementParticleCount() {\n        --this.activeParticleCount;\n\n        // TODO:\n        //  - Trigger event if count === 0.\n    }\n\n    _incrementParticleCount() {\n        ++this.activeParticleCount;\n\n        // TODO:\n        //  - Trigger event if count === this.particleCount.\n    }\n\n    _checkParticleAges( start, end, params, dt ) {\n        for ( var i = end - 1, index, maxAge, age, alive; i >= start; --i ) {\n            index = i * 4;\n\n            alive = params[ index ];\n\n            if ( alive === 0.0 ) {\n                continue;\n            }\n\n            // Increment age\n            age = params[ index + 1 ];\n            maxAge = params[ index + 2 ];\n\n            if ( this.direction === 1 ) {\n                age += dt;\n\n                if ( age >= maxAge ) {\n                    age = 0.0;\n                    alive = 0.0;\n                    this._decrementParticleCount();\n                }\n            }\n            else {\n                age -= dt;\n\n                if ( age <= 0.0 ) {\n                    age = maxAge;\n                    alive = 0.0;\n                    this._decrementParticleCount();\n                }\n            }\n\n            params[ index ] = alive;\n            params[ index + 1 ] = age;\n\n            this._updateAttributeUpdateRange( 'params', i );\n        }\n    }\n\n    _activateParticles( activationStart, activationEnd, params, dtPerParticle ) {\n        var direction = this.direction;\n\n        for ( var i = activationStart, index, dtValue; i < activationEnd; ++i ) {\n            index = i * 4;\n\n            // Don't re-activate particles that aren't dead yet.\n            // if ( params[ index ] !== 0.0 && ( this.particleCount !== 1 || this.activeMultiplier !== 1 ) ) {\n            //     continue;\n            // }\n\n            if ( params[ index ] != 0.0 && this.particleCount !== 1 ) {\n                continue;\n            }\n\n            // Increment the active particle count.\n            this._incrementParticleCount();\n\n            // Mark the particle as alive.\n            params[ index ] = 1.0;\n\n            // Reset the particle\n            this._resetParticle( i );\n\n            // Move each particle being activated to\n            // it's actual position in time.\n            //\n            // This stops particles being 'clumped' together\n            // when frame rates are on the lower side of 60fps\n            // or not constant (a very real possibility!)\n            dtValue = dtPerParticle * ( i - activationStart )\n            params[ index + 1 ] = direction === -1 ? params[ index + 2 ] - dtValue : dtValue;\n\n            this._updateAttributeUpdateRange( 'params', i );\n        }\n    }\n\n    /**\n     * Simulates one frame's worth of particles, updating particles\n     * that are already alive, and marking ones that are currently dead\n     * but should be alive as alive.\n     *\n     * If the emitter is marked as static, then this function will do nothing.\n     *\n     * @param  {Number} dt The number of seconds to simulate (deltaTime)\n     */\n    tick( dt ) {\n        if ( this.isStatic ) {\n            return;\n        }\n\n        if ( this.paramsArray === null ) {\n            this.paramsArray = this.attributes.params.typedArray.array;\n        }\n\n        var start = this.attributeOffset,\n            end = start + this.particleCount,\n            params = this.paramsArray, // vec3( alive, age, maxAge, wiggle )\n            ppsDt = this.particlesPerSecond * this.activeMultiplier * dt,\n            activationIndex = this.activationIndex;\n\n        // Reset the buffer update indices.\n        this._resetBufferRanges();\n\n        // Increment age for those particles that are alive,\n        // and kill off any particles whose age is over the limit.\n        this._checkParticleAges( start, end, params, dt );\n\n        // If the emitter is dead, reset the age of the emitter to zero,\n        // ready to go again if required\n        if ( this.alive === false ) {\n            this.age = 0.0;\n            return;\n        }\n\n        // If the emitter has a specified lifetime and we've exceeded it,\n        // mark the emitter as dead.\n        if ( this.duration !== null && this.age > this.duration ) {\n            this.alive = false;\n            this.age = 0.0;\n            return;\n        }\n\n\n        var activationStart = this.particleCount === 1 ? activationIndex : ( activationIndex | 0 ),\n            activationEnd = Math.min( activationStart + ppsDt, this.activationEnd ),\n            activationCount = activationEnd - this.activationIndex | 0,\n            dtPerParticle = activationCount > 0 ? dt / activationCount : 0;\n\n        this._activateParticles( activationStart, activationEnd, params, dtPerParticle );\n\n        // Move the activation window forward, soldier.\n        this.activationIndex += ppsDt;\n\n        if ( this.activationIndex > end ) {\n            this.activationIndex = start;\n        }\n\n\n        // Increment the age of the emitter.\n        this.age += dt;\n    }\n\n    /**\n     * Resets all the emitter's particles to their start positions\n     * and marks the particles as dead if the `force` argument is\n     * true.\n     *\n     * @param  {Boolean} [force=undefined] If true, all particles will be marked as dead instantly.\n     * @return {Emitter}       This emitter instance.\n     */\n    reset( force ) {\n        this.age = 0.0;\n        this.alive = false;\n\n        if ( force === true ) {\n            var start = this.attributeOffset,\n                end = start + this.particleCount,\n                array = this.paramsArray,\n                attr = this.attributes.params.bufferAttribute;\n\n            for ( var i = end - 1, index; i >= start; --i ) {\n                index = i * 4;\n\n                array[ index ] = 0.0;\n                array[ index + 1 ] = 0.0;\n            }\n\n            attr.updateRange.offset = 0;\n            attr.updateRange.count = -1;\n            attr.needsUpdate = true;\n        }\n\n        return this;\n    }\n\n    /**\n     * Enables the emitter. If not already enabled, the emitter\n     * will start emitting particles.\n     *\n     * @return {Emitter} This emitter instance.\n     */\n    enable() {\n        this.alive = true;\n        return this;\n    }\n\n    /**\n     * Disables th emitter, but does not instantly remove it's\n     * particles fromt the scene. When called, the emitter will be\n     * 'switched off' and just stop emitting. Any particle's alive will\n     * be allowed to finish their lifecycle.\n     *\n     * @return {Emitter} This emitter instance.\n     */\n    disable() {\n        this.alive = false;\n        return this;\n    }\n\n    /**\n     * Remove this emitter from it's parent group (if it has been added to one).\n     * Delgates to SPE.group.prototype.removeEmitter().\n     *\n     * When called, all particle's belonging to this emitter will be instantly\n     * removed from the scene.\n     *\n     * @return {Emitter} This emitter instance.\n     *\n     * @see SPE.Group.prototype.removeEmitter\n     */\n    remove() {\n        if ( this.group !== null ) {\n            this.group.removeEmitter( this );\n        }\n        else {\n            console.error( 'Emitter does not belong to a group, cannot remove.' );\n        }\n\n        return this;\n    }\n};","import {\n    types,\n    ensureTypedArg,\n    ensureInstanceOf\n} from './utils';\nimport { valueOverLifetimeLength, distributions } from '../constants';\nimport ShaderAttribute from '../helpers/ShaderAttribute';\nimport shaders from '../shaders/shaders';\nimport Emitter from './Emitter';\n\nimport { Math as THREEMath } from 'three';\nimport { Texture as THREETexture } from 'three';\nimport { Vector2 as THREEVector2 } from 'three';\nimport { Vector3 as THREEVector3 } from 'three';\nimport { Vector4 as THREEVector4 } from 'three';\nimport { AdditiveBlending as THREEAdditiveBlending } from 'three';\nimport { ShaderMaterial as THREEShaderMaterial } from 'three';\nimport { BufferGeometry as THREEBufferGeometry } from 'three';\nimport { Points as THREEPoints } from 'three';\n\n/**\n * An SPE.Group instance.\n * @typedef {Object} Group\n * @see SPE.Group\n */\n\n/**\n * A map of options to configure an SPE.Group instance.\n * @typedef {Object} GroupOptions\n *\n * @property {Object} texture An object describing the texture used by the group.\n *\n * @property {Object} texture.value An instance of THREE.Texture.\n *\n * @property {Object=} texture.frames A THREE.Vector2 instance describing the number\n *                                    of frames on the x- and y-axis of the given texture.\n *                                    If not provided, the texture will NOT be treated as\n *                                    a sprite-sheet and as such will NOT be animated.\n *\n * @property {Number} [texture.frameCount=texture.frames.x * texture.frames.y] The total number of frames in the sprite-sheet.\n *                                                                   Allows for sprite-sheets that don't fill the entire\n *                                                                   texture.\n *\n * @property {Number} texture.loop The number of loops through the sprite-sheet that should\n *                                 be performed over the course of a single particle's lifetime.\n *\n * @property {Number} fixedTimeStep If no `dt` (or `deltaTime`) value is passed to this group's\n *                                  `tick()` function, this number will be used to move the particle\n *                                  simulation forward. Value in SECONDS.\n *\n * @property {Boolean} hasPerspective Whether the distance a particle is from the camera should affect\n *                                    the particle's size.\n *\n * @property {Boolean} colorize Whether the particles in this group should be rendered with color, or\n *                              whether the only color of particles will come from the provided texture.\n *\n * @property {Number} blending One of Three.js's blending modes to apply to this group's `ShaderMaterial`.\n *\n * @property {Boolean} transparent Whether these particle's should be rendered with transparency.\n *\n * @property {Number} alphaTest Sets the alpha value to be used when running an alpha test on the `texture.value` property. Value between 0 and 1.\n *\n * @property {Boolean} depthWrite Whether rendering the group has any effect on the depth buffer.\n *\n * @property {Boolean} depthTest Whether to have depth test enabled when rendering this group.\n *\n * @property {Boolean} fog Whether this group's particles should be affected by their scene's fog.\n *\n * @property {Number} scale The scale factor to apply to this group's particle sizes. Useful for\n *                          setting particle sizes to be relative to renderer size.\n */\n\n\n/**\n * The SPE.Group class. Creates a new group, containing a material, geometry, and mesh.\n *\n * @constructor\n * @param {GroupOptions} options A map of options to configure the group instance.\n */\nexport default class Group {\n    constructor( options = {} ) {\n        // Ensure we have a map of options to play with\n        options.texture = ensureTypedArg( options.texture, types.OBJECT, {} );\n\n        // Assign a UUID to this instance\n        this.uuid = THREEMath.generateUUID();\n\n        // If no `deltaTime` value is passed to the `SPE.Group.tick` function,\n        // the value of this property will be used to advance the simulation.\n        this.fixedTimeStep = ensureTypedArg( options.fixedTimeStep, types.NUMBER, 0.016 );\n\n        // Set properties used in the uniforms map, starting with the\n        // texture stuff.\n        this.texture = ensureInstanceOf( options.texture.value, THREETexture, null );\n        this.textureFrames = ensureInstanceOf( options.texture.frames, THREEVector2, new THREEVector2( 1, 1 ) );\n        this.textureFrameCount = ensureTypedArg( options.texture.frameCount, types.NUMBER, this.textureFrames.x * this.textureFrames.y );\n        this.textureLoop = ensureTypedArg( options.texture.loop, types.NUMBER, 1 );\n        this.textureFrames.max( new THREEVector2( 1, 1 ) );\n\n        this.hasPerspective = ensureTypedArg( options.hasPerspective, types.BOOLEAN, true );\n        this.colorize = ensureTypedArg( options.colorize, types.BOOLEAN, true );\n\n        this.maxParticleCount = ensureTypedArg( options.maxParticleCount, types.NUMBER, null );\n\n\n        // Set properties used to define the ShaderMaterial's appearance.\n        this.blending = ensureTypedArg( options.blending, types.NUMBER, THREEAdditiveBlending );\n        this.transparent = ensureTypedArg( options.transparent, types.BOOLEAN, true );\n        this.alphaTest = parseFloat( ensureTypedArg( options.alphaTest, types.NUMBER, 0.0 ) );\n        this.depthWrite = ensureTypedArg( options.depthWrite, types.BOOLEAN, false );\n        this.depthTest = ensureTypedArg( options.depthTest, types.BOOLEAN, true );\n        this.fog = ensureTypedArg( options.fog, types.BOOLEAN, true );\n        this.scale = ensureTypedArg( options.scale, types.NUMBER, 300 );\n\n        // Where emitter's go to curl up in a warm blanket and live\n        // out their days.\n        this.emitters = [];\n        this.emitterIDs = [];\n\n        // Create properties for use by the emitter pooling functions.\n        this._pool = [];\n        this._poolCreationSettings = null;\n        this._createNewWhenPoolEmpty = 0;\n\n        // Whether all attributes should be forced to updated\n        // their entire buffer contents on the next tick.\n        //\n        // Used when an emitter is removed.\n        this._attributesNeedRefresh = false;\n        this._attributesNeedDynamicReset = false;\n\n        this.particleCount = 0;\n\n\n        // Map of uniforms to be applied to the ShaderMaterial instance.\n        this.uniforms = {\n            texture: {\n                type: 't',\n                value: this.texture\n            },\n            textureAnimation: {\n                type: 'v4',\n                value: new THREEVector4(\n                    this.textureFrames.x,\n                    this.textureFrames.y,\n                    this.textureFrameCount,\n                    Math.max( Math.abs( this.textureLoop ), 1.0 )\n                )\n            },\n            fogColor: {\n                type: 'c',\n                value: null\n            },\n            fogNear: {\n                type: 'f',\n                value: 10\n            },\n            fogFar: {\n                type: 'f',\n                value: 200\n            },\n            fogDensity: {\n                type: 'f',\n                value: 0.5\n            },\n            deltaTime: {\n                type: 'f',\n                value: 0\n            },\n            runTime: {\n                type: 'f',\n                value: 0\n            },\n            scale: {\n                type: 'f',\n                value: this.scale\n            }\n        };\n\n        // Add some defines into the mix...\n        this.defines = {\n            HAS_PERSPECTIVE: this.hasPerspective,\n            COLORIZE: this.colorize,\n            VALUE_OVER_LIFETIME_LENGTH: valueOverLifetimeLength,\n\n            SHOULD_ROTATE_TEXTURE: false,\n            SHOULD_ROTATE_PARTICLES: false,\n            SHOULD_WIGGLE_PARTICLES: false,\n\n            SHOULD_CALCULATE_SPRITE: this.textureFrames.x > 1 || this.textureFrames.y > 1\n        };\n\n        // Map of all attributes to be applied to the particles.\n        //\n        // See ShaderAttribute for a bit more info on this bit.\n        this.attributes = {\n            position: new ShaderAttribute( 'v3', true ),\n            acceleration: new ShaderAttribute( 'v4', true ), // w component is drag\n            velocity: new ShaderAttribute( 'v3', true ),\n            rotation: new ShaderAttribute( 'v4', true ),\n            rotationCenter: new ShaderAttribute( 'v3', true ),\n            params: new ShaderAttribute( 'v4', true ), // Holds (alive, age, delay, wiggle)\n            size: new ShaderAttribute( 'v4', true ),\n            angle: new ShaderAttribute( 'v4', true ),\n            color: new ShaderAttribute( 'v4', true ),\n            opacity: new ShaderAttribute( 'v4', true )\n        };\n\n        this.attributeKeys = Object.keys( this.attributes );\n        this.attributeCount = this.attributeKeys.length;\n\n        // Create the ShaderMaterial instance that'll help render the\n        // particles.\n        this.material = new THREEShaderMaterial( {\n            uniforms: this.uniforms,\n            vertexShader: shaders.vertex,\n            fragmentShader: shaders.fragment,\n            blending: this.blending,\n            transparent: this.transparent,\n            alphaTest: this.alphaTest,\n            depthWrite: this.depthWrite,\n            depthTest: this.depthTest,\n            defines: this.defines,\n            fog: this.fog\n        } );\n\n        // Create the BufferGeometry and Points instances, ensuring\n        // the geometry and material are given to the latter.\n        this.geometry = new THREEBufferGeometry();\n        this.mesh = new THREEPoints( this.geometry, this.material );\n\n        if ( this.maxParticleCount === null ) {\n            console.warn( 'SPE.Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors.' );\n        }\n    }\n\n    _updateDefines() {\n        var emitters = this.emitters,\n            i = emitters.length - 1,\n            emitter,\n            defines = this.defines;\n\n        for ( i; i >= 0; --i ) {\n            emitter = emitters[ i ];\n\n            // Only do angle calculation if there's no spritesheet defined.\n            //\n            // Saves calculations being done and then overwritten in the shaders.\n            if ( !defines.SHOULD_CALCULATE_SPRITE ) {\n                defines.SHOULD_ROTATE_TEXTURE = defines.SHOULD_ROTATE_TEXTURE || !!Math.max(\n                    Math.max.apply( null, emitter.angle.value ),\n                    Math.max.apply( null, emitter.angle.spread )\n                );\n            }\n\n            defines.SHOULD_ROTATE_PARTICLES = defines.SHOULD_ROTATE_PARTICLES || !!Math.max(\n                emitter.rotation.angle,\n                emitter.rotation.angleSpread\n            );\n\n            defines.SHOULD_WIGGLE_PARTICLES = defines.SHOULD_WIGGLE_PARTICLES || !!Math.max(\n                emitter.wiggle.value,\n                emitter.wiggle.spread\n            );\n        }\n\n        this.material.needsUpdate = true;\n    }\n\n    _applyAttributesToGeometry() {\n        var attributes = this.attributes,\n            geometry = this.geometry,\n            geometryAttributes = geometry.attributes,\n            attribute,\n            geometryAttribute;\n\n        // Loop through all the shader attributes and assign (or re-assign)\n        // typed array buffers to each one.\n        for ( var attr in attributes ) {\n            if ( attributes.hasOwnProperty( attr ) ) {\n                attribute = attributes[ attr ];\n                geometryAttribute = geometryAttributes[ attr ];\n\n                // Update the array if this attribute exists on the geometry.\n                //\n                // This needs to be done because the attribute's typed array might have\n                // been resized and reinstantiated, and might now be looking at a\n                // different ArrayBuffer, so reference needs updating.\n                if ( geometryAttribute ) {\n                    geometryAttribute.array = attribute.typedArray.array;\n                }\n\n                // // Add the attribute to the geometry if it doesn't already exist.\n                else {\n                    geometry.addAttribute( attr, attribute.bufferAttribute );\n                }\n\n                // Mark the attribute as needing an update the next time a frame is rendered.\n                attribute.bufferAttribute.needsUpdate = true;\n            }\n        }\n\n        // Mark the draw range on the geometry. This will ensure\n        // only the values in the attribute buffers that are\n        // associated with a particle will be used in THREE's\n        // render cycle.\n        this.geometry.setDrawRange( 0, this.particleCount );\n    }\n\n    /**\n     * Adds an SPE.Emitter instance to this group, creating particle values and\n     * assigning them to this group's shader attributes.\n     *\n     * @param {Emitter} emitter The emitter to add to this group.\n     */\n    addEmitter( emitter ) {\n        // Ensure an actual emitter instance is passed here.\n        //\n        // Decided not to throw here, just in case a scene's\n        // rendering would be pause d. Logging an error instead\n        // of stopping execution if exceptions aren't caught.\n        if ( emitter instanceof Emitter === false ) {\n            console.error( '`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter );\n            return;\n        }\n\n        // If the emitter already exists as a member of this group, then\n        // stop here, we don't want to add it again.\n        else if ( this.emitterIDs.indexOf( emitter.uuid ) > -1 ) {\n            console.error( 'Emitter already exists in this group. Will not add again.' );\n            return;\n        }\n\n        // And finally, if the emitter is a member of another group,\n        // don't add it to this group.\n        else if ( emitter.group !== null ) {\n            console.error( 'Emitter already belongs to another group. Will not add to requested group.' );\n            return;\n        }\n\n        var attributes = this.attributes,\n            start = this.particleCount,\n            end = start + emitter.particleCount;\n\n        // Update this group's particle count.\n        this.particleCount = end;\n\n        // Emit a warning if the emitter being added will exceed the buffer sizes specified.\n        if ( this.maxParticleCount !== null && this.particleCount > this.maxParticleCount ) {\n            console.warn( 'SPE.Group: maxParticleCount exceeded. Requesting', this.particleCount, 'particles, can support only', this.maxParticleCount );\n        }\n\n\n        // Set the `particlesPerSecond` value (PPS) on the emitter.\n        // It's used to determine how many particles to release\n        // on a per-frame basis.\n        emitter._calculatePPSValue( emitter.maxAge._value + emitter.maxAge._spread );\n        emitter._setBufferUpdateRanges( this.attributeKeys );\n\n        // Store the offset value in the TypedArray attributes for this emitter.\n        emitter._setAttributeOffset( start );\n\n        // Save a reference to this group on the emitter so it knows\n        // where it belongs.\n        emitter.group = this;\n\n        // Store reference to the attributes on the emitter for\n        // easier access during the emitter's tick function.\n        emitter.attributes = this.attributes;\n\n\n\n        // Ensure the attributes and their BufferAttributes exist, and their\n        // TypedArrays are of the correct size.\n        for ( var attr in attributes ) {\n            if ( attributes.hasOwnProperty( attr ) ) {\n                // When creating a buffer, pass through the maxParticle count\n                // if one is specified.\n                attributes[ attr ]._createBufferAttribute(\n                    this.maxParticleCount !== null ?\n                    this.maxParticleCount :\n                    this.particleCount\n                );\n            }\n        }\n\n        // Loop through each particle this emitter wants to have, and create the attributes values,\n        // storing them in the TypedArrays that each attribute holds.\n        for ( var i = start; i < end; ++i ) {\n            emitter._assignPositionValue( i );\n            emitter._assignForceValue( i, 'velocity' );\n            emitter._assignForceValue( i, 'acceleration' );\n            emitter._assignAbsLifetimeValue( i, 'opacity' );\n            emitter._assignAbsLifetimeValue( i, 'size' );\n            emitter._assignAngleValue( i );\n            emitter._assignRotationValue( i );\n            emitter._assignParamsValue( i );\n            emitter._assignColorValue( i );\n        }\n\n        // Update the geometry and make sure the attributes are referencing\n        // the typed arrays properly.\n        this._applyAttributesToGeometry();\n\n        // Store this emitter in this group's emitter's store.\n        this.emitters.push( emitter );\n        this.emitterIDs.push( emitter.uuid );\n\n        // Update certain flags to enable shader calculations only if they're necessary.\n        this._updateDefines( emitter );\n\n        // Update the material since defines might have changed\n        this.material.needsUpdate = true;\n        this.geometry.needsUpdate = true;\n        this._attributesNeedRefresh = true;\n\n        // Return the group to enable chaining.\n        return this;\n    }\n\n    /**\n     * Removes an SPE.Emitter instance from this group. When called,\n     * all particle's belonging to the given emitter will be instantly\n     * removed from the scene.\n     *\n     * @param {Emitter} emitter The emitter to add to this group.\n     */\n    removeEmitter( emitter ) {\n        var emitterIndex = this.emitterIDs.indexOf( emitter.uuid );\n\n        // Ensure an actual emitter instance is passed here.\n        //\n        // Decided not to throw here, just in case a scene's\n        // rendering would be paused. Logging an error instead\n        // of stopping execution if exceptions aren't caught.\n        if ( emitter instanceof Emitter === false ) {\n            console.error( '`emitter` argument must be instance of SPE.Emitter. Was provided with:', emitter );\n            return;\n        }\n\n        // Issue an error if the emitter isn't a member of this group.\n        else if ( emitterIndex === -1 ) {\n            console.error( 'Emitter does not exist in this group. Will not remove.' );\n            return;\n        }\n\n        // Kill all particles by marking them as dead\n        // and their age as 0.\n        var start = emitter.attributeOffset,\n            end = start + emitter.particleCount,\n            params = this.attributes.params.typedArray;\n\n        // Set alive and age to zero.\n        for ( var i = start; i < end; ++i ) {\n            params.array[ i * 4 ] = 0.0;\n            params.array[ i * 4 + 1 ] = 0.0;\n        }\n\n        // Remove the emitter from this group's \"store\".\n        this.emitters.splice( emitterIndex, 1 );\n        this.emitterIDs.splice( emitterIndex, 1 );\n\n        // Remove this emitter's attribute values from all shader attributes.\n        // The `.splice()` call here also marks each attribute's buffer\n        // as needing to update it's entire contents.\n        for ( var attr in this.attributes ) {\n            if ( this.attributes.hasOwnProperty( attr ) ) {\n                this.attributes[ attr ].splice( start, end );\n            }\n        }\n\n        // Ensure this group's particle count is correct.\n        this.particleCount -= emitter.particleCount;\n\n        // Call the emitter's remove method.\n        emitter._onRemove();\n\n        // Set a flag to indicate that the attribute buffers should\n        // be updated in their entirety on the next frame.\n        this._attributesNeedRefresh = true;\n    }\n\n\n    /**\n     * Fetch a single emitter instance from the pool.\n     * If there are no objects in the pool, a new emitter will be\n     * created if specified.\n     *\n     * @return {Emitter|null}\n     */\n    getFromPool() {\n        var pool = this._pool,\n            createNew = this._createNewWhenPoolEmpty;\n\n        if ( pool.length ) {\n            return pool.pop();\n        }\n        else if ( createNew ) {\n            return new Emitter( this._poolCreationSettings );\n        }\n\n        return null;\n    }\n\n\n    /**\n     * Release an emitter into the pool.\n     *\n     * @param  {ShaderParticleEmitter} emitter\n     * @return {Group} This group instance.\n     */\n    releaseIntoPool( emitter ) {\n        if ( emitter instanceof Emitter === false ) {\n            console.error( 'Argument is not instanceof SPE.Emitter:', emitter );\n            return;\n        }\n\n        emitter.reset();\n        this._pool.unshift( emitter );\n\n        return this;\n    }\n\n\n    /**\n     * Get the pool array\n     *\n     * @return {Array}\n     */\n    getPool() {\n        return this._pool;\n    }\n\n\n    /**\n     * Add a pool of emitters to this particle group\n     *\n     * @param {Number} numEmitters      The number of emitters to add to the pool.\n     * @param {EmitterOptions|Array} emitterOptions  An object, or array of objects, describing the options to pass to each emitter.\n     * @param {Boolean} createNew       Should a new emitter be created if the pool runs out?\n     * @return {Group} This group instance.\n     */\n    addPool( numEmitters, emitterOptions, createNew ) {\n        var emitter;\n\n        // Save relevant settings and flags.\n        this._poolCreationSettings = emitterOptions;\n        this._createNewWhenPoolEmpty = !!createNew;\n\n        // Create the emitters, add them to this group and the pool.\n        for ( var i = 0; i < numEmitters; ++i ) {\n            if ( Array.isArray( emitterOptions ) ) {\n                emitter = new Emitter( emitterOptions[ i ] );\n            }\n            else {\n                emitter = new Emitter( emitterOptions );\n            }\n            this.addEmitter( emitter );\n            this.releaseIntoPool( emitter );\n        }\n\n        return this;\n    }\n\n\n\n    _triggerSingleEmitter( pos ) {\n        var emitter = this.getFromPool(),\n            self = this;\n\n        if ( emitter === null ) {\n            console.log( 'SPE.Group pool ran out.' );\n            return;\n        }\n\n        // TODO:\n        // - Make sure buffers are update with thus new position.\n        if ( pos instanceof THREEVector3 ) {\n            emitter.position.value.copy( pos );\n\n            // Trigger the setter for this property to force an\n            // update to the emitter's position attribute.\n            emitter.position.value = emitter.position.value;\n        }\n\n        emitter.enable();\n\n        setTimeout( function() {\n            emitter.disable();\n            self.releaseIntoPool( emitter );\n        }, ( Math.max( emitter.duration, ( emitter.maxAge.value + emitter.maxAge.spread ) ) ) * 1000 );\n\n        return this;\n    }\n\n\n    /**\n     * Set a given number of emitters as alive, with an optional position\n     * vector3 to move them to.\n     *\n     * @param  {Number} numEmitters The number of emitters to activate\n     * @param  {Object} [position=undefined] A THREE.Vector3 instance describing the position to activate the emitter(s) at.\n     * @return {Group} This group instance.\n     */\n    triggerPoolEmitter( numEmitters, position ) {\n        if ( typeof numEmitters === 'number' && numEmitters > 1 ) {\n            for ( var i = 0; i < numEmitters; ++i ) {\n                this._triggerSingleEmitter( position );\n            }\n        }\n        else {\n            this._triggerSingleEmitter( position );\n        }\n\n        return this;\n    }\n\n\n\n    _updateUniforms( dt ) {\n        this.uniforms.runTime.value += dt;\n        this.uniforms.deltaTime.value = dt;\n    }\n\n    _resetBufferRanges() {\n        var keys = this.attributeKeys,\n            i = this.attributeCount - 1,\n            attrs = this.attributes;\n\n        for ( i; i >= 0; --i ) {\n            attrs[ keys[ i ] ].resetUpdateRange();\n        }\n    }\n\n\n    _updateBuffers( emitter ) {\n        var keys = this.attributeKeys,\n            i = this.attributeCount - 1,\n            attrs = this.attributes,\n            emitterRanges = emitter.bufferUpdateRanges,\n            key,\n            emitterAttr,\n            attr;\n\n        for ( i; i >= 0; --i ) {\n            key = keys[ i ];\n            emitterAttr = emitterRanges[ key ];\n            attr = attrs[ key ];\n            attr.setUpdateRange( emitterAttr.min, emitterAttr.max );\n            attr.flagUpdate();\n        }\n    }\n\n\n    /**\n     * Simulate all the emitter's belonging to this group, updating\n     * attribute values along the way.\n     * @param  {Number} [dt=Group's `fixedTimeStep` value] The number of seconds to simulate the group's emitters for (deltaTime)\n     */\n    tick( dt ) {\n        var emitters = this.emitters,\n            numEmitters = emitters.length,\n            deltaTime = dt || this.fixedTimeStep,\n            keys = this.attributeKeys,\n            i,\n            attrs = this.attributes;\n\n        // Update uniform values.\n        this._updateUniforms( deltaTime );\n\n        // Reset buffer update ranges on the shader attributes.\n        this._resetBufferRanges();\n\n\n        // If nothing needs updating, then stop here.\n        if (\n            numEmitters === 0 &&\n            this._attributesNeedRefresh === false &&\n            this._attributesNeedDynamicReset === false\n        ) {\n            return;\n        }\n\n        // Loop through each emitter in this group and\n        // simulate it, then update the shader attribute\n        // buffers.\n        for ( var i = 0, emitter; i < numEmitters; ++i ) {\n            emitter = emitters[ i ];\n            emitter.tick( deltaTime );\n            this._updateBuffers( emitter );\n        }\n\n        // If the shader attributes have been refreshed,\n        // then the dynamic properties of each buffer\n        // attribute will need to be reset back to\n        // what they should be.\n        if ( this._attributesNeedDynamicReset === true ) {\n            i = this.attributeCount - 1;\n\n            for ( i; i >= 0; --i ) {\n                attrs[ keys[ i ] ].resetDynamic();\n            }\n\n            this._attributesNeedDynamicReset = false;\n        }\n\n        // If this group's shader attributes need a full refresh\n        // then mark each attribute's buffer attribute as\n        // needing so.\n        if ( this._attributesNeedRefresh === true ) {\n            i = this.attributeCount - 1;\n\n            for ( i; i >= 0; --i ) {\n                attrs[ keys[ i ] ].forceUpdateAll();\n            }\n\n            this._attributesNeedRefresh = false;\n            this._attributesNeedDynamicReset = true;\n        }\n    }\n\n\n    /**\n     * Dipose the geometry and material for the group.\n     *\n     * @return {Group} Group instance.\n     */\n    dispose() {\n        this.geometry.dispose();\n        this.material.dispose();\n        return this;\n    }\n};","import { distributions, typeSizeMap, valueOverLifetimeLength } from './constants';\n\nimport shaderChunks from './shaders/shaderChunks';\nimport shaders from './shaders/shaders';\n\nimport ShaderAttribute from './helpers/ShaderAttribute';\nimport TypedArrayHelper from './helpers/TypedArrayHelper';\n\nimport * as utils from './core/utils';\nimport Emitter from './core/Emitter';\nimport Group from './core/Group';\n\nexport default {\n\tdistributions,\n\ttypeSizeMap,\n\tvalueOverLifetimeLength,\n\tshaderChunks,\n\tshaders,\n\tShaderAttribute,\n\tTypedArrayHelper,\n\tutils,\n\tEmitter,\n\tGroup\n};;"],"names":["BOX","SPHERE","DISC","f","v2","v3","v4","c","m3","m4","defines","join","uniforms","attributes","varyings","branchAvoidanceFunctions","unpackColor","unpackRotationAxis","floatOverLifetime","colorOverLifetime","paramFetchingFunctions","forceFetchingFunctions","rotationFunctions","rotateTexture","vertex","shaderChunks","ShaderChunk","common","logdepthbuf_pars_vertex","logdepthbuf_vertex","fragment","fog_pars_fragment","logdepthbuf_pars_fragment","logdepthbuf_fragment","fog_fragment","type","dynamicBuffer","Float32Array","typeSizeMap","typeMap","hasOwnProperty","componentSize","arrayType","typedArray","bufferAttribute","updateMin","updateMax","min","max","Math","range","attr","updateRange","offset","count","array","length","needsUpdate","dynamic","start","end","splice","forceUpdateAll","size","setSize","TypedArrayHelper","_ensureTypedArray","TypedArrayConstructor","indexOffset","noComponentMultiply","currentArraySize","shrink","grow","console","info","subarray","newArray","set","existingArray","i","data","push","setFromArray","index","newSize","sourceArraySize","vec2","setVec2Components","x","y","vec3","setVec3Components","z","vec4","setVec4Components","w","mat3","elements","mat4","color","r","g","b","numericValue","BOOLEAN","STRING","NUMBER","OBJECT","arg","defaultValue","Array","isArray","instance","undefined","property","minLength","maxLength","_value","_spread","clamp","spreadLength","desiredLength","valueLength","interpolateArray","srcArray","newLength","clone","factor","sourceLength","before","floor","after","ceil","delta","lerpTypeAgnostic","value","randomise","result","random","epsilon","types","out","lerp","warn","n","multiple","remainder","abs","base","spread","attribute","spreadClamp","roundToNearestMultiple","colors","numItems","workingColor","copy","spreadVector","getHex","radius","radiusSpread","radiusScale","radiusSpreadClamp","distributionClamp","t","sqrt","depth","rand","randomFloat","round","cos","sin","seed","posX","posY","posZ","emitterPosition","speed","speedSpread","v","normalize","multiplyScalar","vSpread","addOne","axis","axisSpread","add","setRGB","valueOverLifetimeLength","options","position","ensureTypedArg","velocity","acceleration","drag","rotation","opacity","angle","wiggle","maxAge","onParticleSpawn","uuid","THREEMath","generateUUID","distributions","ensureInstanceOf","THREEVector3","_spreadClamp","_distribution","distribution","_randomise","_radius","_radiusScale","_distributionClamp","_axis","_axisSpread","_angle","_angleSpread","angleSpread","_static","static","_center","center","ensureArrayInstanceOf","THREEColor","ensureArrayTypedArg","particleCount","duration","isStatic","activeMultiplier","direction","alive","particlesPerSecond","activationIndex","attributeOffset","attributeEnd","age","activeParticleCount","group","paramsArray","resetFlags","rotationCenter","updateFlags","updateCounts","updateMap","_createGetterSetters","bufferUpdateRanges","attributeKeys","attributeCount","ensureValueOverLifetimeCompliance","lifetimeLength","propObj","propName","replace","Object","defineProperty","name","get","prop","self","prevValue","mapName","_updateDefines","keys","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","groupMaxAge","startIndex","activationEnd","_assignPositionValue","_assignForceValue","_assignAbsLifetimeValue","_assignAngleValue","_assignParamsValue","_assignRotationValue","_assignColorValue","SPE","utils","randomVector3","randomVector3OnSphere","randomVector3OnDisc","attrName","pos","positionX","positionY","positionZ","randomDirectionVector3OnSphere","randomDirectionVector3OnDisc","arrayValuesAreEqual","params","getPackedRotationAxis","setVec3","randomColorAsHex","key","updateFlag","_assignValue","_updateAttributeUpdateRange","ranges","bufferUpdateKeys","bufferUpdateCount","dt","_decrementParticleCount","activationStart","dtPerParticle","dtValue","_incrementParticleCount","_resetParticle","ppsDt","_resetBufferRanges","_checkParticleAges","activationCount","_activateParticles","force","removeEmitter","error","texture","fixedTimeStep","THREETexture","textureFrames","frames","THREEVector2","textureFrameCount","frameCount","textureLoop","loop","hasPerspective","colorize","maxParticleCount","blending","THREEAdditiveBlending","transparent","alphaTest","parseFloat","depthWrite","depthTest","fog","scale","emitters","emitterIDs","_pool","_poolCreationSettings","_createNewWhenPoolEmpty","_attributesNeedRefresh","_attributesNeedDynamicReset","textureAnimation","fogColor","fogNear","fogFar","fogDensity","deltaTime","runTime","HAS_PERSPECTIVE","COLORIZE","VALUE_OVER_LIFETIME_LENGTH","SHOULD_ROTATE_TEXTURE","SHOULD_ROTATE_PARTICLES","SHOULD_WIGGLE_PARTICLES","SHOULD_CALCULATE_SPRITE","material","vertexShader","shaders","fragmentShader","geometry","mesh","emitter","apply","geometryAttributes","geometryAttribute","addAttribute","setDrawRange","indexOf","_calculatePPSValue","_setBufferUpdateRanges","_setAttributeOffset","_createBufferAttribute","_applyAttributesToGeometry","emitterIndex","_onRemove","createNew","pool","pop","reset","unshift","numEmitters","emitterOptions","addEmitter","releaseIntoPool","getFromPool","log","enable","setTimeout","disable","_triggerSingleEmitter","attrs","resetUpdateRange","emitterRanges","emitterAttr","setUpdateRange","flagUpdate","_updateUniforms","tick","_updateBuffers","resetDynamic","dispose","ShaderAttribute","Emitter","Group"],"mappings":"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"}